<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Minecraft Mobile v4.0</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* UI Layer */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 12px; height: 12px;
            background: rgba(255, 255, 255, 0.8); border: 1px solid black;
            transform: translate(-50%, -50%);
        }

        /* Instructions */
        #hint { position: absolute; top: 10px; left: 0; width: 100%; text-align: center; color: white; text-shadow: 1px 1px 0 #000; font-size: 14px; pointer-events: none; opacity: 0.8; }

        /* Controls */
        #joystick-zone { position: absolute; bottom: 30px; left: 30px; width: 140px; height: 140px; pointer-events: auto; }
        #look-zone { position: absolute; top: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; }

        /* Jump Button */
        #btn-jump { 
            position: absolute; bottom: 120px; right: 30px; width: 80px; height: 80px; 
            background: rgba(0,0,0,0.3); border: 2px solid rgba(255,255,255,0.5); 
            border-radius: 50%; pointer-events: auto; 
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 16px;
        }
        #btn-jump:active { background: rgba(255,255,255,0.2); }

        /* Inventory */
        #inventory {
            position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(0,0,0,0.5); padding: 8px; border-radius: 12px;
            pointer-events: auto;
        }
        .slot {
            width: 40px; height: 40px; border: 2px solid #333; border-radius: 6px;
            transition: transform 0.1s; cursor: pointer;
        }
        .slot.active { border-color: #fff; transform: scale(1.1); box-shadow: 0 0 8px white; }
        
        /* Colors */
        .c-grass { background: #567d46; }
        .c-dirt { background: #5c4033; }
        .c-stone { background: #808080; }
        .c-wood { background: #4a3728; }
        .c-leaves { background: #228b22; }
        .c-sand { background: #eecfa1; }
        .c-plank { background: #8B4513; }
        .c-brick { background: #800000; }
    </style>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="hint">TAP to Place &nbsp;|&nbsp; HOLD to Break</div>
        <div id="crosshair"></div>
        <div id="joystick-zone"></div>
        <div id="look-zone"></div>
        <div id="btn-jump">JUMP</div>

        <div id="inventory">
            <div class="slot c-grass active" data-type="grass"></div>
            <div class="slot c-dirt" data-type="dirt"></div>
            <div class="slot c-stone" data-type="stone"></div>
            <div class="slot c-wood" data-type="wood"></div>
            <div class="slot c-leaves" data-type="leaves"></div>
            <div class="slot c-sand" data-type="sand"></div>
            <div class="slot c-plank" data-type="plank"></div>
            <div class="slot c-brick" data-type="brick"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>

    <script>
        // --- CONFIG ---
        const WORLD_SIZE = 16; // Smaller radius for better FPS
        const RENDER_DIST = 25;
        const MOVE_SPEED = 0.13;
        const JUMP_FORCE = 0.23; // Adjusted for better feel
        const GRAVITY = 0.011;
        const PLAYER_WIDTH = 0.3; // Collision width radius
        const HOLD_TIME = 400; // ms to trigger break
        
        // --- GLOBALS ---
        let scene, camera, renderer;
        let objects = []; 
        let blockMap = new Map();
        let crabs = [];
        
        // Player
        let player = new THREE.Object3D();
        let head = new THREE.Object3D();
        let velocity = new THREE.Vector3();
        let onGround = false;
        let moveFwd = 0, moveSide = 0;
        
        // Interaction
        let raycaster = new THREE.Raycaster();
        let currentMat = 'grass';
        let materials = {};
        let blockGeo; // Shared geometry
        let touchTimer = null;
        let isHolding = false;

        init();
        animate();

        function init() {
            // 1. Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 5, RENDER_DIST);

            // 2. Camera Rig
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 60);
            head.position.y = 1.6;
            head.add(camera);
            player.add(head);
            scene.add(player);
            player.position.set(0, 10, 0);

            // 3. Renderer (OPTIMIZATION: Low Pixel Ratio)
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(1); // Force 1.0 for FPS
            document.getElementById('game-container').appendChild(renderer.domElement);

            // 4. Lights
            const amb = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(amb);
            const sun = new THREE.DirectionalLight(0xffffff, 0.5);
            sun.position.set(10, 30, 10);
            scene.add(sun);

            // 5. Assets
            setupMaterials();
            generateWorld();

            // 6. Controls
            setupInput();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function setupMaterials() {
            // Shared Geometry for performance
            blockGeo = new THREE.BoxGeometry(1, 1, 1);

            const mkMat = (c) => new THREE.MeshLambertMaterial({ color: c });
            materials = {
                grass: mkMat(0x567d46),
                dirt: mkMat(0x5c4033),
                stone: mkMat(0x808080),
                wood: mkMat(0x4a3728),
                leaves: mkMat(0x228b22),
                sand: mkMat(0xeecfa1),
                plank: mkMat(0x8B4513),
                brick: mkMat(0x800000),
                water: new THREE.MeshBasicMaterial({ color: 0x40a4df, transparent: true, opacity: 0.6 }),
                crab: new THREE.MeshLambertMaterial({ color: 0xff4400 })
            };
        }

        function generateWorld() {
            for (let x = -WORLD_SIZE; x <= WORLD_SIZE; x++) {
                for (let z = -WORLD_SIZE; z <= WORLD_SIZE; z++) {
                    // Terrain Math
                    let h = Math.floor(Math.sin(x/5) * 3 + Math.cos(z/6) * 3);
                    
                    // Surface determination
                    let type = 'grass';
                    if (h <= -1) type = 'sand';
                    if (h < -2) h = -2; // Flatten sea floor

                    // Column
                    for (let y = -4; y <= h; y++) {
                        let t = type;
                        if (y < h) t = 'dirt';
                        if (y < h - 2) t = 'stone';
                        createBlock(x, y, z, t);
                    }

                    // Water
                    for (let y = h + 1; y <= -1; y++) {
                        createBlock(x, y, z, 'water');
                    }

                    // Crabs (On sand, near water)
                    if (type === 'sand' && h === -1 && Math.random() < 0.05) {
                        createCrab(x, h + 1, z);
                    }
                }
            }
        }

        function createBlock(x, y, z, type) {
            if(blockMap.has(`${x},${y},${z}`)) return;

            const mesh = new THREE.Mesh(blockGeo, materials[type]);
            mesh.position.set(x, y, z);
            
            // Optimization: Static matrix, no auto update
            mesh.updateMatrix();
            mesh.matrixAutoUpdate = false;

            mesh.userData = { type: type, solid: type !== 'water' };
            
            scene.add(mesh);
            objects.push(mesh);
            blockMap.set(`${x},${y},${z}`, mesh);
            return mesh;
        }

        function createCrab(x, y, z) {
            const crab = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.3), materials.crab);
            crab.add(body);

            // Eyes
            const eyeGeo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
            const eyeMat = new THREE.MeshBasicMaterial({color:0x000000});
            const e1 = new THREE.Mesh(eyeGeo, eyeMat); e1.position.set(0.1, 0.15, 0.15);
            const e2 = new THREE.Mesh(eyeGeo, eyeMat); e2.position.set(-0.1, 0.15, 0.15);
            crab.add(e1); crab.add(e2);

            crab.position.set(x, y, z);
            scene.add(crab);
            crabs.push({ mesh: crab, speed: 0.02, offset: Math.random() * 100 });
        }

        // --- PHYSICS & COLLISION ---
        function checkCollision(pos) {
            // Check bounding box corners for player width
            const range = PLAYER_WIDTH;
            const checks = [
                {x: pos.x, z: pos.z},
                {x: pos.x + range, z: pos.z + range},
                {x: pos.x - range, z: pos.z - range},
                {x: pos.x + range, z: pos.z - range},
                {x: pos.x - range, z: pos.z + range}
            ];

            for (let c of checks) {
                const bx = Math.round(c.x);
                const by = Math.round(pos.y);
                const bz = Math.round(c.z);
                const block = blockMap.get(`${bx},${by},${bz}`);
                if (block && block.userData.solid) return true;
            }
            return false;
        }

        function updatePhysics() {
            // 1. Gravity
            velocity.y -= GRAVITY;

            // 2. Horizontal Movement
            const yaw = player.rotation.y;
            const dx = Math.sin(yaw) * moveFwd + Math.cos(yaw) * moveSide;
            const dz = Math.cos(yaw) * moveFwd - Math.sin(yaw) * moveSide;
            
            // Try X movement
            let nextPos = player.position.clone();
            nextPos.x -= dx * MOVE_SPEED;
            if (!checkCollision(new THREE.Vector3(nextPos.x, player.position.y, player.position.z)) && 
                !checkCollision(new THREE.Vector3(nextPos.x, player.position.y - 1, player.position.z))) {
                player.position.x = nextPos.x;
            }

            // Try Z movement
            nextPos = player.position.clone();
            nextPos.z -= dz * MOVE_SPEED;
            if (!checkCollision(new THREE.Vector3(player.position.x, player.position.y, nextPos.z)) && 
                !checkCollision(new THREE.Vector3(player.position.x, player.position.y - 1, nextPos.z))) {
                player.position.z = nextPos.z;
            }

            // 3. Vertical Movement
            let nextY = player.position.y + velocity.y;
            
            // Check feet
            if (velocity.y < 0 && checkCollision(new THREE.Vector3(player.position.x, nextY - 1.5, player.position.z))) {
                velocity.y = 0;
                onGround = true;
                player.position.y = Math.round(nextY - 1.5) + 1.5 + 0.001; 
            } else if (velocity.y > 0 && checkCollision(new THREE.Vector3(player.position.x, nextY, player.position.z))) {
                // Head bonk
                velocity.y = 0;
            } else {
                player.position.y = nextY;
                onGround = false;
            }

            // Floor boundary
            if (player.position.y < -10) player.position.set(0, 10, 0);
        }

        // --- INPUT SYSTEM ---
        function setupInput() {
            // Inventory Select
            document.querySelectorAll('.slot').forEach(s => {
                s.addEventListener('touchstart', (e) => {
                    e.preventDefault(); e.stopPropagation();
                    document.querySelectorAll('.slot').forEach(el => el.classList.remove('active'));
                    s.classList.add('active');
                    currentMat = s.dataset.type;
                });
            });

            // Jump
            const btnJump = document.getElementById('btn-jump');
            btnJump.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                if (onGround) {
                    velocity.y = JUMP_FORCE;
                    onGround = false;
                }
            });

            // Look & Action Zone
            const zone = document.getElementById('look-zone');
            let lastX, lastY;

            zone.addEventListener('touchstart', (e) => {
                lastX = e.touches[0].pageX;
                lastY = e.touches[0].pageY;
                
                // Start Hold Timer
                isHolding = false;
                touchTimer = setTimeout(() => {
                    isHolding = true;
                    performRaycastAction('BREAK');
                }, HOLD_TIME);

            }, {passive: false});

            zone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                // If moving finger, cancel the hold timer
                if (Math.abs(e.touches[0].pageX - lastX) > 5) {
                    clearTimeout(touchTimer);
                    isHolding = false;
                }

                // Look Logic
                const x = e.touches[0].pageX; 
                const y = e.touches[0].pageY;
                player.rotation.y -= (x - lastX) * 0.005;
                head.rotation.x -= (y - lastY) * 0.005;
                head.rotation.x = Math.max(-1.5, Math.min(1.5, head.rotation.x));
                lastX = x; lastY = y;
            }, {passive: false});

            zone.addEventListener('touchend', (e) => {
                clearTimeout(touchTimer);
                // If we didn't hold long enough, it's a tap -> PLACE
                if (!isHolding) {
                    performRaycastAction('PLACE');
                }
                isHolding = false;
            });

            // Joystick
            const joy = nipplejs.create({
                zone: document.getElementById('joystick-zone'),
                mode: 'static',
                position: { left: '50%', top: '50%' },
                color: 'white'
            });
            joy.on('move', (evt, data) => {
                moveFwd = data.vector.y;
                moveSide = data.vector.x;
            });
            joy.on('end', () => { moveFwd = 0; moveSide = 0; });
        }

        function performRaycastAction(actionType) {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0) {
                const hit = intersects[0];
                if (hit.distance > 6) return;

                if (actionType === 'BREAK') {
                    if (hit.object.userData.type === 'water') return; // Can't break water
                    
                    // FX
                    createParticles(hit.object.position, hit.object.material.color);
                    
                    // Remove
                    scene.remove(hit.object);
                    objects.splice(objects.indexOf(hit.object), 1);
                    const p = hit.object.position;
                    blockMap.delete(`${p.x},${p.y},${p.z}`);
                } 
                else if (actionType === 'PLACE') {
                    const p = hit.point.add(hit.face.normal.multiplyScalar(0.5));
                    const bx = Math.round(p.x), by = Math.round(p.y), bz = Math.round(p.z);
                    
                    // Collision check for placement (don't place inside self)
                    const dist = new THREE.Vector3(bx, by, bz).distanceTo(player.position);
                    if (dist > 1.2) {
                        createBlock(bx, by, bz, currentMat);
                        // FX
                        createParticles(new THREE.Vector3(bx, by, bz), materials[currentMat].color);
                    }
                }
            }
        }

        function createParticles(pos, color) {
            // Simple particle burst
            const geo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            for(let i=0; i<5; i++) {
                const p = new THREE.Mesh(geo, mat);
                p.position.copy(pos);
                p.position.x += (Math.random()-0.5);
                p.position.y += (Math.random()-0.5);
                p.position.z += (Math.random()-0.5);
                scene.add(p);
                // Animate and remove later (simplified for perf)
                setTimeout(() => scene.remove(p), 500);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            updatePhysics();
            renderer.render(scene, camera);

            // Animate Crabs
            const time = Date.now() * 0.002;
            crabs.forEach(c => {
                c.mesh.position.y += Math.sin(time + c.offset) * 0.002; // Bobbing
            });
        }
    </script>
</body>
</html>

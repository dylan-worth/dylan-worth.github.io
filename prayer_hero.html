<!doctype html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
<title>Prayer Hero ‚Äì Fan Remake</title>
<style>
  :root{
    --bg:#0b0b10;
    --lava1:#2b0d0d;
    --lava2:#6a1a1a;
    --panel:#1a1f2a;
    --panel-2:#101420;
    --edge:#313b52;
    --text:#e6e6e6;
    --muted:#a7b0c2;
    --good:#38f57b;
    --ok:#ffd166;
    --miss:#ff5e57;--lane0:#6bf178;
--lane1:#b16bff;
--lane2:#ff9f45;
--lane3:#6bb6ff;

}

html,body{height:100%;} body{ margin:0; background: radial-gradient(1200px 600px at 70% 30%, #1a0f14, #0a070b 60%, #000 90%) , repeating-linear-gradient(120deg, var(--lava1) 0 2px, transparent 2px 6px), repeating-linear-gradient(60deg,  var(--lava2) 0 1px, transparent 1px 5px); background-blend-mode: overlay, screen, normal; color:var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Arial, sans-serif; overflow:hidden; }

.wrap{display:grid; grid-template-columns: 1fr 340px; gap:14px; height:100%;}

.stage{position:relative; display:flex; align-items:center; justify-content:center; height:100%; border-right:2px solid #0008;} canvas{ width:100%; height:100%; display:block; background: linear-gradient(#0c0f17, #0a0c14 65%, #080a10 100%);}

/* LOGO */ .badge{ position:absolute; top:12px; left:50%; transform:translateX(-50%); width:120px; aspect-ratio:1/1; display:grid; place-items:center; filter: drop-shadow(0 8px 20px #000); z-index:3; } .badge .ring{position:absolute; inset:0; border-radius:50%; background:conic-gradient(from 0deg, #d7dbe9 0 10%, #96a3c7 10% 20%, #d7dbe9 20% 30%, #96a3c7 30% 40%, #d7dbe9 40% 50%, #96a3c7 50% 60%, #d7dbe9 60% 70%, #96a3c7 70% 80%, #d7dbe9 80% 90%, #96a3c7 90% 100%); mask: radial-gradient(circle at 50% 50%, transparent 56%, black 57%);}
.badge .text{font-weight:800; text-align:center; letter-spacing:.06em; line-height:1;} .badge .text span{display:block; font-size:18px; color:#e6e6f8} .badge .text strong{display:block; font-size:30px; color:#fff; text-shadow: 0 2px 0 #000, 0 0 12px #7fb1ff;}

/* HUD */ .hud{ height:100%; background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%); border-left: 1px solid #000a; box-shadow: inset 0 0 0 2px #0006, inset 0 0 32px #000c; padding:16px; display:flex; flex-direction:column; gap:16px; } .card{background: linear-gradient(180deg, #111722, #0c121c); border:1px solid var(--edge); border-radius:14px; padding:14px; box-shadow: 0 6px 18px #0008;} .title{font-weight:800; letter-spacing:.04em;} .muted{color:var(--muted); font-size:12px;} .kv{display:grid; grid-template-columns: auto 1fr; gap:6px 12px; align-items:center;} .kv b{font-weight:700} .bars { display:grid; gap:10px; } .bar{height:14px; border-radius:999px; background:#1c2230; border:1px solid #2a3347; box-shadow: inset 0 1px 2px #000; overflow:hidden} .bar>.fill{height:100%; width:0%; background: linear-gradient(90deg, #89ff9f, #59b9ff);} .row{display:flex; gap:10px; align-items:center; justify-content:space-between} .btn{appearance:none; border:none; background:#1e2536; color:#dfe7ff; padding:10px 14px; border-radius:10px; cursor:pointer; border:1px solid #2a3550; font-weight:700} .btn:hover{background:#283148} .btn:active{transform:translateY(1px)} .chip{display:inline-flex; align-items:center; gap:8px; background:#121929; color:#c4d0f6; border:1px solid #28324a; border-radius:999px; padding:8px 12px; font-size:12px;} .dot{width:10px; height:10px; border-radius:50%} .hearts{display:flex; gap:6px} .heart{width:18px; height:18px; background: radial-gradient(circle at 30% 30%, #ff9090, #ff4545 60%, #d70024 61%); clip-path: path('M12 4 C12 2 10 0 8 0 C6 0 4 2 4 4 C4 6 6 8 8 10 C10 8 12 6 12 4 Z'); filter: drop-shadow(0 0 6px #ff1825aa)} .heart.off{opacity:.25; filter:none}

.controls{ position:absolute; left:0; right:340px; bottom:16px; display:flex; justify-content:center; gap:10px; z-index:4; } .key{width:64px; height:64px; border-radius:18px; background:#0c121c; border:2px solid #2f3b55; display:grid; place-items:center; color:#fff; font-weight:800; text-shadow:0 2px 0 #000; user-select:none} .key:active{transform:translateY(2px)} .legend{display:flex; gap:10px; flex-wrap:wrap}

@media (max-width: 980px){ .wrap{grid-template-columns: 1fr;} .hud{position:fixed; bottom:0; left:0; right:0; height:auto; max-height:50%; overflow-y:auto; width:100%; backdrop-filter: blur(6px); opacity:.98; border-left:none; border-top:1px solid #000a; box-shadow: 0 -4px 18px #000c;} .controls{ right:12px; left:12px; bottom:calc(50% + 12px); } .badge { width:90px; } } </style>

</head>
<body>
  <div class="wrap">
    <div class="stage">
      <canvas id="game" aria-label="Prayer Hero game canvas" ></canvas>
      <div class="badge" aria-hidden="true">
        <div class="ring"></div>
        <div class="text"><span>PRAYER</span><strong>HERO</strong></div>
      </div>
      <div class="controls" id="touchControls" hidden>
        <div class="key" data-lane="0">‚óÄÔ∏é</div>
        <div class="key" data-lane="1">‚ñº</div>
        <div class="key" data-lane="2">‚ñ≤</div>
        <div class="key" data-lane="3">‚ñ∂Ô∏é</div>
      </div>
    </div><aside class="hud">
  <div class="card">
    <div class="title">Session</div>
    <div class="kv" style="margin-top:8px">
      <div class="muted">Difficulty</div>
      <div>
        <select id="difficulty">
          <option value="easy">Easy</option>
          <option value="medium" selected>Medium</option>
          <option value="hard">Hard</option>
          <option value="insane">Insane</option>
        </select>
      </div>
      <div class="muted">Length</div>
      <div>
        <select id="length">
          <option value="short">Short (45s)</option>
          <option value="medium" selected>Medium (75s)</option>
          <option value="long">Long (120s)</option>
        </select>
      </div>
      <div class="muted">Speed</div>
      <div>
        <input type="range" id="speed" min="3" max="9" value="5"/>
      </div>
    </div>
    <div class="row" style="margin-top:10px">
      <button id="play" class="btn">‚ñ∂ Start</button>
      <button id="pause" class="btn">‚è∏ Pause</button>
      <button id="restart" class="btn">‚Üª Restart</button>
    </div>
    <div class="legend" style="margin-top:10px">
      <span class="chip"><span class="dot" style="background:var(--lane0)"></span>Left</span>
      <span class="chip"><span class="dot" style="background:var(--lane1)"></span>Down</span>
      <span class="chip"><span class="dot" style="background:var(--lane2)"></span>Up</span>
      <span class="chip"><span class="dot" style="background:var(--lane3)"></span>Right</span>
    </div>
    <div class="muted" style="margin-top:6px">Keys: ‚Üê ‚Üì ‚Üë ‚Üí  (WASD also works)</div>
  </div>

  <div class="card">
    <div class="title">Stats</div>
    <div class="kv" style="margin-top:8px">
      <div class="muted">Score</div><b id="score">0</b>
      <div class="muted">Streak</div><b id="streak">0</b>
      <div class="muted">Multiplier</div><b id="mult">x1</b>
    </div>
    <div class="bars" style="margin-top:10px">
      <div class="bar"><div class="fill" id="timeFill"></div></div>
    </div>
    <div class="row" style="margin-top:10px">
      <div class="muted">Health</div>
      <div class="hearts" id="hearts"></div>
    </div>
  </div>

  <div class="card">
    <div class="title">About</div>
    <div class="muted" style="margin-top:6px">Fan-made rhythm mini-game inspired by the vibe of OSRS. No assets required. Plays in your browser. Have fun and respect the spore. üß™</div>
  </div>
</aside>

    </div><script>
(() => {
  // ===== Utility =====
  const clamp = (n, a, b) => Math.min(Math.max(n, a), b);
  const rand = (a,b) => a + Math.random()*(b-a);

  // ===== Canvas setup (HiDPI) =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;
  function resize(){
    const {clientWidth:w, clientHeight:h} = canvas;
    canvas.width = Math.floor(w*DPR); canvas.height = Math.floor(h*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    laneGeom.compute();
  }
  new ResizeObserver(resize).observe(canvas);

  // ===== Lane geometry (for light perspective look) =====
  const laneGeom = {
    lanes:4, width:0, height:0, hitY:0,
    topW:140, bottomW:520, gap:16, left:0,
    colors:['var(--lane0)','var(--lane1)','var(--lane2)','var(--lane3)'],
    compute(){
      this.width = canvas.clientWidth;
      this.height = canvas.clientHeight;
      this.hitY = this.height - 110; // hit line from bottom
      this.left = (this.width - this.bottomW)/2;
    },
    laneCenter(i, y){
      // linear perspective: lane width grows with y
      const t = clamp((y)/(this.height), 0, 1);
      const w = this.topW*(1-t) + this.bottomW*(t);
      const start = (this.width - w)/2;
      const totalGap = this.gap*(this.lanes-1);
      const laneW = (w - totalGap)/this.lanes;
      return start + i*(laneW+this.gap) + laneW/2;
    },
    laneRadius(y){
      const t = clamp((y)/(this.height), 0, 1);
      const w = this.topW*(1-t) + this.bottomW*(t);
      const totalGap = this.gap*(this.lanes-1);
      const laneW = (w - totalGap)/this.lanes;
      return laneW*0.42;
    }
  };

  // ===== Game State =====
  const state = {
    running:false, paused:false,
    startAt:0, pauseAt:0, duration:75000, // ms
    approach:1500, // ms time for a note to travel
    hitWindow:{good:120, ok:180},
    notes:[], active:[], nextIdx:0,
    score:0, streak:0, mult:1, healthMax:5, health:5,
    speed:5,
  };

  // ===== UI refs =====
  const $ = sel => document.querySelector(sel);
  const scoreEl = $('#score'), streakEl = $('#streak'), multEl = $('#mult');
  const timeFill = $('#timeFill');
  const heartsEl = $('#hearts');
  const playBtn = $('#play'), pauseBtn = $('#pause'), restartBtn = $('#restart');
  const diffSel = $('#difficulty'), lenSel = $('#length'), speedSlider = $('#speed');
  const touchControls = document.getElementById('touchControls');

  function renderHearts(){
    heartsEl.innerHTML = '';
    for(let i=0;i<state.healthMax;i++){
      const d = document.createElement('div');
      d.className = 'heart'+(i<state.health?'':' off');
      heartsEl.appendChild(d);
    }
  }

  // ===== Map generation =====
  function seconds(s){return s*1000}
  function difficultyToParams(diff){
    switch(diff){
      case 'easy': return {bpm:92, density:0.55, approach:1900, windowGood:140, windowOk:200};
      case 'medium': return {bpm:108, density:0.7, approach:1600, windowGood:120, windowOk:180};
      case 'hard': return {bpm:128, density:0.85, approach:1350, windowGood:105, windowOk:160};
      case 'insane': return {bpm:150, density:1.0, approach:1150, windowGood:95, windowOk:140};
    }
  }
  function lengthToMs(len){
    return len==='short'?seconds(45): len==='long'?seconds(120): seconds(75);
  }

  function generateMap({bpm, density}, totalMs){
    const beat = 60000/bpm;
    const map = [];
    let t=0; let lastLane=-1; let doubleChance=0.08 + density*0.06;
    while(t < totalMs){
      // choose whether to place a note on this beat
      if(Math.random() < density){
        let lane = Math.floor(rand(0,4));
        if(lane===lastLane) lane = (lane+1)%4; // avoid long repeats
        lastLane = lane;
        map.push({t:Math.floor(t), lane});
        // occasional double notes (not adjacent lanes for fairness)
        if(Math.random() < doubleChance){
          const other = (lane + (Math.random()>0.5?2:1))%4;
          map.push({t:Math.floor(t), lane:other});
        }
      }
      // quarter-beat granularity (adds fun syncopation)
      t += (Math.random()<0.25? beat/2 : beat);
    }
    // sort by time & lane for stability
    map.sort((a,b)=> a.t===b.t ? a.lane-b.lane : a.t-b.t);
    return map;
  }

  // ===== Audio (tiny beeps with WebAudio) =====
  const audio = {
    ctx:null,
    ensure(){ if(!this.ctx) this.ctx = new (window.AudioContext||window.webkitAudioContext)(); },
    beep(lane){
      this.ensure();
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type='triangle';
      const base = 330; // Hz
      o.frequency.value = base + lane*70;
      g.gain.value = 0.12;
      o.connect(g).connect(this.ctx.destination);
      o.start();
      o.stop(this.ctx.currentTime + 0.09);
    },
    whiff(){ // miss sound
      this.ensure();
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type='sawtooth';
      o.frequency.value = 140;
      g.gain.setValueAtTime(0.12, this.ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime+0.12);
      o.connect(g).connect(this.ctx.destination);
      o.start(); o.stop(this.ctx.currentTime+0.14);
    }
  };

  // ===== Input =====
  const laneForKey = (code) => {
    switch(code){
      case 'ArrowLeft': case 'KeyA': return 0;
      case 'ArrowDown': case 'KeyS': return 1;
      case 'ArrowUp':   case 'KeyW': return 2;
      case 'ArrowRight':case 'KeyD': return 3;
      default: return -1;
    }
  };

  const pressed = new Set();
  window.addEventListener('keydown', (e)=>{
    if(e.repeat) return;
    const lane = laneForKey(e.code);
    if(lane!==-1){ e.preventDefault(); hit(lane); pressed.add(lane);}    
  });
  window.addEventListener('keyup', (e)=>{
    const lane = laneForKey(e.code);
    if(lane!==-1) pressed.delete(lane);
  });

  // Touch controls visibility
  function maybeShowTouch(){
    const isTouch = matchMedia('(hover: none)').matches || 'ontouchstart' in window;
    touchControls.hidden = !isTouch;
  }
  maybeShowTouch();
  touchControls.addEventListener('touchstart', (e)=>{
    const btn = e.target.closest('.key'); if(!btn) return;
    e.preventDefault(); hit(Number(btn.dataset.lane));
  });

  // ===== Hit Logic =====
  function nowMs(){
    if(!state.running) return 0;
    const t = performance.now();
    return t - state.startAt;
  }

  function scheduleNotes(){
    state.active.length = 0; state.nextIdx = 0;
  }

  function effectiveApproach(){
    // speed slider modifies approach (higher speed -> lower approach time)
    const s = state.speed; // 3..9
    const minA = state.approach*0.65, maxA = state.approach*1.35;
    const t = (s-3)/(9-3);
    return maxA*(1-t) + minA*(t);
  }

  function hit(lane){
    if(!state.running || state.paused) return;
    const t = nowMs();
    // find earliest hittable note in this lane within window
    let targetIdx = -1; let deltaMin = Infinity;
    for(let i=0;i<state.notes.length;i++){
      const n = state.notes[i];
      if(n.hit) continue; if(n.lane!==lane) continue;
      const d = Math.abs(n.t - t);
      if(d < deltaMin){ deltaMin = d; targetIdx = i; }
      if(n.t > t + state.hitWindow.ok) break; // notes are sorted
    }

    if(targetIdx!==-1 && deltaMin <= state.hitWindow.ok){
      const n = state.notes[targetIdx];
      n.hit = true; n.res = (deltaMin <= state.hitWindow.good? 'good':'ok');
      // scoring
      const add = n.res==='good'? 100 : 50;
      state.streak++; if(state.streak%10===0) state.mult = Math.min(8, state.mult+1);
      state.score += add * state.mult; audio.beep(lane);
      flashAtLane(lane, n.res);
    } else {
      // ghost tap = tiny penalty
      audio.whiff();
      state.streak = 0; state.mult = 1;
      loseHp(0.2);
      flashAtLane(lane, 'miss');
    }
    updateHud();
  }

  function loseHp(qty=1){
    state.health = clamp(state.health - qty, 0, state.healthMax);
    renderHearts();
    if(state.health<=0){ endRun(); }
  }

  // ===== Visual FX =====
  const sparks = [];
  function flashAtLane(lane, type){
    const y = laneGeom.hitY;
    const x = laneGeom.laneCenter(lane, y);
    sparks.push({x,y,life:0.3, type});
  }

  // ===== Run Control =====
  function startRun(){
    // read config
    const params = difficultyToParams(diffSel.value);
    state.duration = lengthToMs(lenSel.value);
    state.approach = params.approach;
    state.hitWindow.good = params.windowGood;
    state.hitWindow.ok = params.windowOk;
    state.speed = Number(speedSlider.value);

    state.notes = generateMap(params, state.duration);
    state.score = 0; state.streak = 0; state.mult = 1; state.health = state.healthMax; renderHearts();
    scheduleNotes();
    updateHud();

    state.running = true; state.paused=false;
    state.startAt = performance.now();
    loop();
  }

  function pauseRun(){
    if(!state.running || state.paused) return;
    state.paused = true; state.pauseAt = performance.now();
  }
  function resumeRun(){
    if(!state.running || !state.paused) return;
    const dt = performance.now() - state.pauseAt;
    state.startAt += dt; state.paused=false; loop();
  }
  function endRun(){
    state.running=false; state.paused=false;
    // tiny banner
    const msg = `Run over ‚Äî Score ${state.score}  |  Max Streak ${state.streak}`;
    toast(msg);
  }
  function restart(){ startRun(); }

  playBtn.addEventListener('click', ()=>{ if(!state.running) startRun(); else resumeRun(); });
  pauseBtn.addEventListener('click', ()=> pauseRun());
  restartBtn.addEventListener('click', ()=> restart());

  speedSlider.addEventListener('input', ()=>{ state.speed = Number(speedSlider.value); });

  // ===== Heads-up display =====
  function updateHud(){
    scoreEl.textContent = state.score|0;
    streakEl.textContent = state.streak|0;
    multEl.textContent = `x${state.mult}`;
  }

  function setTimeProgress(p){ timeFill.style.width = (p*100).toFixed(1)+'%'; }

  function toast(text){
    const d = document.createElement('div');
    d.textContent = text; d.style.position='absolute'; d.style.left='50%'; d.style.top='18px';
    d.style.transform='translateX(-50%)'; d.style.padding='10px 14px'; d.style.border='1px solid #2a3550';
    d.style.background='#0f1421cc'; d.style.borderRadius='10px'; d.style.zIndex=99; d.style.backdropFilter='blur(2px)';
    d.style.boxShadow='0 10px 20px #0007';
    document.body.appendChild(d); setTimeout(()=>d.remove(), 2600);
  }

  // ===== Main loop =====
  function loop(){
    if(!state.running) return;
    if(state.paused) return;

    const t = nowMs();
    // activate notes that should be visible soon
    const A = effectiveApproach();
    while(state.nextIdx < state.notes.length && state.notes[state.nextIdx].t - t < A){
      state.active.push(state.notes[state.nextIdx]);
      state.nextIdx++;
    }

    // miss window check
    for(const n of state.active){
      if(!n.hit && t - n.t > state.hitWindow.ok + 60){ n.hit=true; n.res='miss'; state.streak=0; state.mult=1; loseHp(1); }
    }

    // draw
    draw(t, A);

    // end condition
    const p = clamp(t/state.duration,0,1); setTimeProgress(p);
    if(t >= state.duration && state.health>0){ endRun(); return; }

    requestAnimationFrame(loop);
  }

  function draw(t, approach){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // background tunnel glow
    const grad = ctx.createRadialGradient(w/2, h*0.2, 10, w/2, h*0.2, Math.max(w,h)*0.6);
    grad.addColorStop(0,'#2a1137'); grad.addColorStop(1,'#07080c');
    ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

    // path deck (simple perspective rectangle)
    ctx.save();
    ctx.fillStyle = '#121721';
    ctx.strokeStyle = '#313b52';
    ctx.beginPath();
    const topW = laneGeom.topW, bottomW = laneGeom.bottomW;
    const topX = (w-topW)/2, bottomX = (w-bottomW)/2;
    ctx.moveTo(topX, h*0.1); ctx.lineTo(topX+topW, h*0.1); ctx.lineTo(bottomX+bottomW, h*0.96); ctx.lineTo(bottomX, h*0.96); ctx.closePath();
    ctx.fill(); ctx.globalAlpha=.35; ctx.stroke(); ctx.globalAlpha=1;

    // hit line
    ctx.strokeStyle='#4461a8'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(bottomX, laneGeom.hitY); ctx.lineTo(bottomX+bottomW, laneGeom.hitY); ctx.stroke();

    // lanes (subtle separators)
    for(let i=1;i<4;i++){
      const y1 = h*0.11, y2=h*0.95; // slight inward curve illusion by lerp of centers
      const cx1 = laneGeom.laneCenter(i, y1), cx2 = laneGeom.laneCenter(i, y2);
      ctx.strokeStyle = '#25304a'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(cx1, y1); ctx.lineTo(cx2, y2); ctx.stroke();
    }

    // notes
    for(const n of state.active){
      if(n.hit && n.res==='miss') continue; // already missed and faded via HP
      const prog = clamp(1 - (n.t - t)/approach, 0, 1);
      const y = h*0.12 + prog*(laneGeom.hitY - h*0.12);
      const x = laneGeom.laneCenter(n.lane, y);
      const r = laneGeom.laneRadius(y);
      const color = getComputedStyle(document.documentElement).getPropertyValue(['--lane0','--lane1','--lane2','--lane3'][n.lane]).trim();

      // ring
      ctx.save();
      ctx.fillStyle = '#0c0f16';
      ctx.strokeStyle = '#3a4667'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();

      // inner disc
      const rr = r*0.62; const grad2 = ctx.createRadialGradient(x-r*0.3,y-r*0.3, rr*0.2, x,y, rr);
      grad2.addColorStop(0, color);
      grad2.addColorStop(1, '#000');
      ctx.fillStyle = grad2; ctx.beginPath(); ctx.arc(x,y,rr,0,Math.PI*2); ctx.fill();

      // If just hit, briefly flash
      if(n.hit && (n.res==='good'||n.res==='ok')){
        const age = (t - n.t);
        if(age < 160){
          ctx.globalAlpha = 1 - age/160; ctx.strokeStyle = n.res==='good'? '#7dffa6':'#ffe18a'; ctx.lineWidth=6; ctx.beginPath(); ctx.arc(x,y, r*0.95, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
        }
      }
      ctx.restore();
    }

    // pressed key glows at hit line
    for(let i=0;i<4;i++){
      const y = laneGeom.hitY;
      const x = laneGeom.laneCenter(i, y);
      const r = laneGeom.laneRadius(y)*0.9;
      ctx.save();
      ctx.globalAlpha = pressed.has(i)? 1 : .55;
      const color = getComputedStyle(document.documentElement).getPropertyValue(['--lane0','--lane1','--lane2','--lane3'][i]).trim();
      ctx.strokeStyle = '#40507a'; ctx.lineWidth=4; ctx.fillStyle = '#0c1018';
      ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
      ctx.globalAlpha = pressed.has(i)? 0.45 : 0.18;
      ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y, r*0.6, 0, Math.PI*2); ctx.fill();
      ctx.restore();
    }

    // sparks
    for(let i=sparks.length-1;i>=0;i--){
      const s = sparks[i];
      s.life -= 1/60; if(s.life<=0){ sparks.splice(i,1); continue; }
      const a = clamp(s.life/0.3, 0, 1);
      ctx.globalAlpha = a;
      ctx.strokeStyle = s.type==='miss'? 'var(--miss)': s.type==='good'? 'var(--good)':'var(--ok)';
      ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(s.x, s.y, 42*(1-a), 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1;
    }

    ctx.restore();
  }

  // ===== Boot =====
  resize(); renderHearts(); updateHud(); setTimeProgress(0);
})();
</script></body>
</html>
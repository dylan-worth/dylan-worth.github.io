<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Forest Portfolio</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', sans-serif; user-select: none; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }

        /* UI LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

        /* INVENTORY (Top Left) */
        #inventory {
            position: absolute; top: 20px; left: 20px; display: flex; gap: 10px; pointer-events: auto;
        }
        .inv-slot {
            background: rgba(0,0,0,0.6); border: 2px solid #5d4037; color: #e6c86e;
            width: 50px; height: 50px; display: flex; flex-direction: column;
            align-items: center; justify-content: center; border-radius: 8px; font-size: 10px; cursor: pointer;
        }
        .inv-slot.active { border-color: #e6c86e; background: rgba(230, 200, 110, 0.2); }
        .inv-icon { font-size: 20px; }

        /* TIME DISPLAY (Top Center) */
        #time-display {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: white; text-shadow: 0 2px 2px black; font-weight: bold;
        }

        /* ZOOM (Right) */
        #zoom-controls {
            position: absolute; top: 50%; right: 20px; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 10px; pointer-events: auto;
        }
        .hud-btn {
            width: 40px; height: 40px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3);
            border-radius: 50%; color: white; display: flex; align-items: center; justify-content: center; font-size: 20px; cursor: pointer;
        }

        /* ACTION BUTTON */
        #action-btn {
            position: absolute; bottom: 50px; right: 40px; width: 80px; height: 80px;
            background: #e6c86e; border: 4px solid #5d4037; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; font-weight: bold;
            color: #3e2723; pointer-events: auto; transition: all 0.2s; opacity: 0.5;
        }
        #action-btn.ready { opacity: 1; transform: scale(1.1); cursor: pointer; }

        /* JOYSTICK */
        #joystick-zone {
            position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.05); border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%; pointer-events: auto;
        }
        #stick {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(230, 200, 110, 0.8); border-radius: 50%; transform: translate(-50%, -50%);
        }

        /* MODAL */
        #interaction-modal {
            position: absolute; top: 30%; left: 50%; transform: translate(-50%, -50%) scale(0.8);
            background: rgba(20, 20, 20, 0.95); border: 2px solid #e6c86e; padding: 20px;
            border-radius: 10px; text-align: center; color: #e6c86e; opacity: 0; pointer-events: none; transition: 0.3s;
        }
        #interaction-modal.active { opacity: 1; transform: translate(-50%, -50%) scale(1); pointer-events: auto; }
        .btn-visit { margin-top:10px; display:inline-block; padding:8px 16px; background:#e6c86e; color:black; text-decoration:none; border-radius:4px; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div id="time-display">12:00 PM</div>

        <div id="inventory">
            <div class="inv-slot active" id="btn-flashlight" onclick="toggleFlashlight()">
                <div class="inv-icon">ðŸ”¦</div>
            </div>
            <div class="inv-slot">
                <div class="inv-icon">ðŸªµ</div>
                <div id="wood-count">0</div>
            </div>
        </div>

        <div id="zoom-controls">
            <div class="hud-btn" onclick="adjustZoom(-5)">+</div>
            <div class="hud-btn" onclick="adjustZoom(5)">-</div>
        </div>

        <div id="action-btn" onclick="performAction()">
            <span id="action-text">...</span>
        </div>

        <div id="interaction-modal">
            <h2 id="modal-title">TITLE</h2>
            <p id="modal-desc">Desc</p>
            <a href="#" id="modal-link" class="btn-visit">VIEW</a>
        </div>

        <div id="joystick-zone">
            <div id="stick"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- STATE ---
        const STATE = {
            wood: 0,
            flashlight: true,
            zoom: 20,
            nearbyTree: null,
            nearbyPOI: null,
            time: 0.5, // 0 to 1 (0.5 = Noon)
            location: 'OUTSIDE' // OUTSIDE or INSIDE
        };

        const CONFIG = {
            mapRadius: 45,
            dayColor: new THREE.Color(0x87CEEB),
            nightColor: new THREE.Color(0x050510),
            cabinPos: new THREE.Vector3(-10, 0, -10)
        };

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(CONFIG.dayColor, 10, 50);
        scene.background = CONFIG.dayColor;

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTING (Dynamic) ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffaa00, 1);
        sunLight.position.set(50, 50, 0);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.top = 50;
        sunLight.shadow.camera.bottom = -50;
        sunLight.shadow.camera.left = -50;
        sunLight.shadow.camera.right = 50;
        scene.add(sunLight);

        // Player Light
        const playerLight = new THREE.SpotLight(0xffffff, 0);
        playerLight.angle = Math.PI / 4;
        playerLight.penumbra = 0.5;
        playerLight.distance = 40;
        playerLight.castShadow = true;
        scene.add(playerLight);
        scene.add(playerLight.target);

        // Campfire Light
        const fireLight = new THREE.PointLight(0xff4400, 0, 15);
        fireLight.position.set(0, 2, 0);
        scene.add(fireLight);

        // --- WORLD OBJECTS ---

        // 1. Ground
        const ground = new THREE.Mesh(
            new THREE.CircleGeometry(50, 64),
            new THREE.MeshStandardMaterial({ color: 0x2e7d32, roughness: 0.8 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // 2. Player
        const player = new THREE.Mesh(
            new THREE.CapsuleGeometry(0.4, 0.8, 4, 8),
            new THREE.MeshStandardMaterial({ color: 0xffaa00 })
        );
        player.position.set(5, 0.6, 5);
        player.castShadow = true;
        scene.add(player);

        // 3. Campfire (Center)
        const fireGroup = new THREE.Group();
        for(let i=0; i<3; i++) {
            const log = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.2), new THREE.MeshStandardMaterial({color:0x5d4037}));
            log.rotation.z = Math.PI/2;
            log.rotation.y = (i/3) * Math.PI*2;
            log.position.y = 0.1;
            fireGroup.add(log);
        }
        // Fire particles (visual only simple mesh)
        const fireMesh = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 5), new THREE.MeshBasicMaterial({color: 0xff4400}));
        fireMesh.position.y = 0.5;
        fireGroup.add(fireMesh);
        scene.add(fireGroup);


        // 4. Cabin (Exterior)
        const cabinGroup = new THREE.Group();
        cabinGroup.position.copy(CONFIG.cabinPos);
        
        // Walls
        const walls = new THREE.Mesh(
            new THREE.BoxGeometry(6, 4, 6),
            new THREE.MeshStandardMaterial({ color: 0x4e342e })
        );
        walls.position.y = 2;
        walls.castShadow = true;
        cabinGroup.add(walls);
        
        // Roof
        const roof = new THREE.Mesh(
            new THREE.ConeGeometry(5.5, 3, 4),
            new THREE.MeshStandardMaterial({ color: 0x3e2723 })
        );
        roof.position.y = 5.5;
        roof.rotation.y = Math.PI/4;
        cabinGroup.add(roof);

        // Door (Black hole)
        const door = new THREE.Mesh(new THREE.PlaneGeometry(2, 3), new THREE.MeshBasicMaterial({ color: 0x000000 }));
        door.position.set(0, 1.5, 3.1);
        cabinGroup.add(door);

        scene.add(cabinGroup);

        // 5. INTERIOR (Located far away)
        const interiorGroup = new THREE.Group();
        interiorGroup.position.set(0, -100, 0); // Far below map
        scene.add(interiorGroup);

        // Floor
        const intFloor = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.MeshStandardMaterial({color: 0x8d6e63}));
        intFloor.rotation.x = -Math.PI/2;
        interiorGroup.add(intFloor);

        // Back Wall (For Badges)
        const intWall = new THREE.Mesh(new THREE.BoxGeometry(20, 10, 1), new THREE.MeshStandardMaterial({color: 0xe0e0e0}));
        intWall.position.set(0, 5, -10);
        interiorGroup.add(intWall);

        // Badges (Certs)
        const badges = [
            { name: "CERT: CIE", color: 0xff0000, x: -5 },
            { name: "CERT: MRSA", color: 0x00ff00, x: 0 },
            { name: "CERT: MICRO", color: 0x0000ff, x: 5 }
        ];

        badges.forEach(b => {
            const badge = new THREE.Mesh(new THREE.BoxGeometry(3, 4, 0.5), new THREE.MeshStandardMaterial({color: b.color}));
            badge.position.set(b.x, 5, -9);
            interiorGroup.add(badge);
            
            // Text Label simulation (White box)
            const label = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.5), new THREE.MeshBasicMaterial({color: 0xffffff}));
            label.position.set(b.x, 3.5, -8.7);
            interiorGroup.add(label);
        });

        // Interior Light
        const intLight = new THREE.PointLight(0xffaa00, 1, 20);
        intLight.position.set(0, 8, 0);
        interiorGroup.add(intLight);


        // --- UTILITIES (Trees & Logic) ---
        let treeObjects = [];
        
        function createTree(x, z, scale=1) {
            const g = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2*scale, 0.4*scale, 2*scale), new THREE.MeshStandardMaterial({color: 0x3e2723}));
            trunk.position.y = scale;
            trunk.castShadow = true;
            g.add(trunk);
            
            const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.5*scale, 3*scale), new THREE.MeshStandardMaterial({color: 0x145a32}));
            leaves.position.y = 2.5*scale;
            leaves.castShadow = true;
            g.add(leaves);
            
            g.position.set(x, 0, z);
            g.userData = { isTree: true, growing: scale===0.1, scale: scale };
            if(scale===0.1) g.scale.set(0.1,0.1,0.1);
            
            scene.add(g);
            treeObjects.push(g);
        }

        // Generate Forest (Avoid center and cabin)
        for(let i=0; i<60; i++) {
            let x = (Math.random()-0.5)*80;
            let z = (Math.random()-0.5)*80;
            const dist = Math.sqrt(x*x + z*z);
            const distCabin = Math.sqrt((x-CONFIG.cabinPos.x)**2 + (z-CONFIG.cabinPos.z)**2);
            
            if(dist > 5 && distCabin > 6 && dist < CONFIG.mapRadius - 2) {
                createTree(x, z);
            }
        }

        // --- CONTROLS ---
        window.adjustZoom = (v) => { STATE.zoom = Math.max(10, Math.min(40, STATE.zoom + v)); };
        window.toggleFlashlight = () => { 
            STATE.flashlight = !STATE.flashlight;
            document.getElementById('btn-flashlight').classList.toggle('active');
        };

        window.performAction = () => {
            if(STATE.nearbyTree) {
                // Chop
                scene.remove(STATE.nearbyTree);
                treeObjects = treeObjects.filter(t => t !== STATE.nearbyTree);
                STATE.wood++;
                document.getElementById('wood-count').innerText = STATE.wood;
                STATE.nearbyTree = null;
            } else if (STATE.wood > 0 && STATE.location === 'OUTSIDE') {
                // Plant
                const dir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
                const pos = player.position.clone().add(dir.multiplyScalar(2));
                createTree(pos.x, pos.z, 1); // Plant new tree
                treeObjects[treeObjects.length-1].userData.growing = true;
                STATE.wood--;
                document.getElementById('wood-count').innerText = STATE.wood;
            }
        };

        // Joystick
        const stick = { x: 0, y: 0 };
        const stickEl = document.getElementById('stick');
        const zone = document.getElementById('joystick-zone');
        
        function handleInput(cx, cy, end) {
            if(end) { stick.x=0; stick.y=0; stickEl.style.transform=`translate(-50%,-50%)`; return; }
            const rect = zone.getBoundingClientRect();
            let dx = cx - (rect.left+rect.width/2);
            let dy = cy - (rect.top+rect.height/2);
            const dist = Math.sqrt(dx*dx+dy*dy);
            if(dist>40) { dx*=40/dist; dy*=40/dist; }
            stickEl.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            stick.x = dx/40; stick.y = dy/40;
        }
        
        zone.addEventListener('touchmove', e=>{e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY)}, {passive:false});
        zone.addEventListener('touchend', ()=>handleInput(0,0,true));
        
        // Mouse for testing
        let drag=false;
        zone.addEventListener('mousedown', e=>{drag=true; handleInput(e.clientX, e.clientY)});
        window.addEventListener('mousemove', e=>{if(drag)handleInput(e.clientX, e.clientY)});
        window.addEventListener('mouseup', ()=>{drag=false; handleInput(0,0,true)});


        // --- MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Day/Night Cycle
            STATE.time += 0.0005; // Speed of day
            if(STATE.time > 1) STATE.time = 0;
            
            const sunY = Math.sin(STATE.time * Math.PI) * 100;
            const sunIntensity = Math.max(0, Math.sin(STATE.time * Math.PI));
            const isNight = sunIntensity < 0.2;
            
            // Visual Updates
            sunLight.position.y = sunY;
            sunLight.position.x = Math.cos(STATE.time * Math.PI) * 50;
            sunLight.intensity = sunIntensity;
            
            const skyColor = CONFIG.dayColor.clone().lerp(CONFIG.nightColor, 1 - sunIntensity);
            scene.background = skyColor;
            scene.fog.color = skyColor;
            
            // Fire Logic
            fireLight.intensity = isNight ? 10 + Math.random()*5 : 0;
            fireMesh.visible = isNight || sunIntensity < 0.5;

            // Flashlight Logic
            if(STATE.location === 'OUTSIDE') {
                playerLight.intensity = (STATE.flashlight && isNight) ? 2 : 0;
            } else {
                playerLight.intensity = 0; // No flashlight inside
            }

            // HUD Time
            const hour = Math.floor(STATE.time * 24);
            document.getElementById('time-display').innerText = `${hour}:00`;


            // 2. Movement
            if(Math.abs(stick.x)>0.1 || Math.abs(stick.y)>0.1) {
                const speed = 0.15;
                player.position.x += stick.x * speed;
                player.position.z += stick.y * speed;
                player.rotation.y = Math.atan2(-stick.x, -stick.y);
            }

            // 3. Constraints & Teleports
            if (STATE.location === 'OUTSIDE') {
                // Map Boundary
                const distCenter = Math.sqrt(player.position.x**2 + player.position.z**2);
                if (distCenter > CONFIG.mapRadius) {
                    const angle = Math.atan2(player.position.z, player.position.x);
                    player.position.x = Math.cos(angle) * CONFIG.mapRadius;
                    player.position.z = Math.sin(angle) * CONFIG.mapRadius;
                }

                // Check Cabin Door
                const distDoor = player.position.distanceTo(new THREE.Vector3(CONFIG.cabinPos.x, 1.5, CONFIG.cabinPos.z + 3));
                if (distDoor < 1.5) {
                    STATE.location = 'INSIDE';
                    player.position.set(0, -99, 5); // Teleport In
                    camera.position.set(0, -90, 20); // Move Cam
                    player.rotation.y = Math.PI;
                }
            } else {
                // Inside Logic
                // Limit movement inside
                if(player.position.x < -9) player.position.x = -9;
                if(player.position.x > 9) player.position.x = 9;
                if(player.position.z < -9) player.position.z = -9;
                if(player.position.z > 9) player.position.z = 9;

                // Check Exit
                if (player.position.z > 8) {
                    STATE.location = 'OUTSIDE';
                    player.position.set(CONFIG.cabinPos.x, 0.6, CONFIG.cabinPos.z + 5); // Teleport Out
                }
            }

            // 4. Camera Follow
            if(STATE.location === 'OUTSIDE') {
                const camOffset = new THREE.Vector3(0, STATE.zoom, STATE.zoom - 5);
                camera.position.lerp(player.position.clone().add(camOffset), 0.1);
                camera.lookAt(player.position);
                
                // Update Flashlight Target
                const targetPos = new THREE.Vector3(player.position.x + (stick.x*5), 0, player.position.z + (stick.y*5));
                playerLight.position.copy(player.position);
                playerLight.position.y += 2;
                playerLight.target.position.lerp(targetPos, 0.1);
            } else {
                // Interior Camera (Fixed angle)
                camera.position.lerp(new THREE.Vector3(0, -90, 15), 0.1);
                camera.lookAt(0, -95, -10);
            }

            // 5. Action Button Logic
            const btn = document.getElementById('action-btn');
            const txt = document.getElementById('action-text');
            
            // Check Trees
            let closest = null;
            let minDist = 2;
            if(STATE.location === 'OUTSIDE') {
                treeObjects.forEach(t => {
                    if(t.userData.growing) {
                        t.userData.scale += 0.02;
                        t.scale.setScalar(t.userData.scale);
                        if(t.userData.scale>=1) t.userData.growing=false;
                    }
                    const d = player.position.distanceTo(t.position);
                    if(d<minDist) { minDist=d; closest=t; }
                });
            }
            STATE.nearbyTree = closest;

            if (STATE.nearbyTree) {
                btn.classList.add('ready'); btn.style.background='#e74c3c'; txt.innerText='CHOP';
            } else if (STATE.wood > 0 && STATE.location === 'OUTSIDE') {
                btn.classList.add('ready'); btn.style.background='#27ae60'; txt.innerText='PLANT';
            } else {
                btn.classList.remove('ready'); btn.style.background='#e6c86e'; txt.innerText='...';
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aesthetic Glass Chess - Fixed</title>
    <style>
        body { margin: 0; background: #020205; overflow: hidden; font-family: 'Segoe UI', sans-serif; cursor: crosshair; }
        #ui {
            position: absolute; top: 30px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); letter-spacing: 4px; text-transform: uppercase;
            pointer-events: none; font-size: 12px;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="ui">Liquid Logic // Click to Select</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- Environment ---
        const genEnv = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            grad.addColorStop(0, '#112233'); grad.addColorStop(1, '#000000');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 512, 512);
            const tex = new THREE.CanvasTexture(canvas);
            tex.mapping = THREE.EquirectangularReflectionMapping;
            return tex;
        };
        scene.environment = genEnv();

        // --- Materials ---
        const lightMat = new THREE.MeshPhysicalMaterial({
            transmission: 1.0, thickness: 1.5, roughness: 0.02, ior: 1.33,
            color: 0xffffff, attenuationColor: 0x00ffff, attenuationDistance: 0.5, clearcoat: 1.0
        });

        const darkMat = new THREE.MeshPhysicalMaterial({
            transmission: 1.0, thickness: 1.5, roughness: 0.05, ior: 1.45,
            color: 0x222222, attenuationColor: 0xff0066, attenuationDistance: 0.4, clearcoat: 1.0
        });

        // --- Board ---
        const board = new THREE.Mesh(
            new THREE.BoxGeometry(8.5, 0.4, 8.5),
            new THREE.MeshPhysicalMaterial({ transmission: 0.9, roughness: 0.1, thickness: 1, color: 0xffffff })
        );
        board.position.y = -0.25;
        scene.add(board);
        scene.add(new THREE.GridHelper(8, 8, 0x00ffff, 0x333333));

        // --- Geometries ---
        const geos = {
            pawn: new THREE.SphereGeometry(0.3, 32, 32),
            rook: new THREE.BoxGeometry(0.5, 0.7, 0.5),
            knight: new THREE.TorusKnotGeometry(0.2, 0.07, 64, 8),
            bishop: new THREE.ConeGeometry(0.3, 0.9, 32),
            queen: new THREE.OctahedronGeometry(0.5, 0),
            king: new THREE.CylinderGeometry(0.25, 0.4, 1.2, 4)
        };

        const pieces = [];
        const spawnPiece = (type, x, z, mat) => {
            const piece = new THREE.Mesh(geos[type], mat.clone());
            piece.userData = { type, baseHeight: 0.5, originalColor: mat.color.getHex() };
            piece.position.set(x - 3.5, 0.5, z - 3.5);
            scene.add(piece);
            pieces.push(piece);
        };

        const layout = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
        for (let i = 0; i < 8; i++) {
            spawnPiece(layout[i], i, 0, lightMat);
            spawnPiece('pawn', i, 1, lightMat);
            spawnPiece(layout[i], i, 7, darkMat);
            spawnPiece('pawn', i, 6, darkMat);
        }

        // --- Interaction Logic ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selected = null;

        window.addEventListener('mousedown', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(pieces);
            if (intersects.length > 0) {
                if (selected) selected.material.emissive.setHex(0x000000);
                selected = intersects[0].object;
                selected.material.emissive.setHex(0x00ffff); // Glow when selected
                selected.position.y = 0.8; // Lift slightly
            }
        });

        // --- Lights ---
        const p1 = new THREE.PointLight(0x00ffff, 50); p1.position.set(5, 5, 5); scene.add(p1);
        const p2 = new THREE.PointLight(0xff00ff, 30); p2.position.set(-5, 5, -5); scene.add(p2);

        camera.position.set(0, 10, 10);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        function animate(t) {
            requestAnimationFrame(animate);
            const time = t * 0.001;
            
            pieces.forEach(p => {
                // Fixed Animation: Bobbing without accumulation
                const offset = Math.sin(time * 2 + p.position.x) * 0.05;
                const targetY = (p === selected) ? 0.8 : 0.5;
                p.position.y = targetY + offset;
                p.rotation.y += 0.01;
            });

            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>

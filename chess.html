<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Liquid Chess</title>
    <style>
        body { margin: 0; background: #020205; overflow: hidden; font-family: 'Courier New', monospace; }
        #ui {
            position: absolute; bottom: 40px; width: 100%; text-align: center;
            color: #00ffff; letter-spacing: 2px; pointer-events: none;
            text-shadow: 0 0 8px #00ffff;
        }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="ui">PIECES SECURED // CLICK TO MOVE</div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- Materials ---
        const glassMat = (c, a) => new THREE.MeshPhysicalMaterial({
            transmission: 1, thickness: 1, ior: 1.33, color: c, attenuationColor: a, attenuationDistance: 0.5, roughness: 0.02
        });
        const whiteMat = glassMat(0xffffff, 0x00ffff);
        const blackMat = glassMat(0x444444, 0xff0066);

        // --- Board & Grid ---
        const squares = [];
        for (let x = 0; x < 8; x++) {
            for (let z = 0; z < 8; z++) {
                const geo = new THREE.BoxGeometry(0.9, 0.1, 0.9);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: (x + z) % 2 === 0 ? 0x111111 : 0x000000,
                    transparent: true, opacity: 0.5
                });
                const sq = new THREE.Mesh(geo, mat);
                sq.position.set(x - 3.5, 0, z - 3.5);
                sq.userData = { x, z };
                scene.add(sq);
                squares.push(sq);
            }
        }

        // --- Piece Logic ---
        const geos = {
            pawn: new THREE.SphereGeometry(0.25, 24, 24),
            rook: new THREE.BoxGeometry(0.5, 0.6, 0.5),
            knight: new THREE.TorusKnotGeometry(0.15, 0.05, 64, 8),
            bishop: new THREE.ConeGeometry(0.25, 0.8, 24),
            queen: new THREE.OctahedronGeometry(0.4),
            king: new THREE.CylinderGeometry(0.2, 0.4, 1, 4)
        };

        const pieces = [];
        function spawn(type, x, z, team) {
            const mesh = new THREE.Mesh(geos[type], team === 'white' ? whiteMat.clone() : blackMat.clone());
            mesh.userData = { type, team, x, z };
            scene.add(mesh);
            pieces.push(mesh);
            updatePiecePos(mesh);
        }

        function updatePiecePos(p) {
            p.position.x = p.userData.x - 3.5;
            p.position.z = p.userData.z - 3.5;
            p.position.y = 0.5;
        }

        const layout = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
        for(let i=0; i<8; i++) {
            spawn(layout[i], i, 0, 'white'); spawn('pawn', i, 1, 'white');
            spawn(layout[i], i, 7, 'black'); spawn('pawn', i, 6, 'black');
        }

        // --- Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selected = null;

        window.addEventListener('click', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const hitPiece = raycaster.intersectObjects(pieces)[0];
            const hitSquare = raycaster.intersectObjects(squares)[0];

            if (hitPiece) {
                if(selected) selected.scale.set(1, 1, 1);
                selected = hitPiece.object;
                selected.scale.set(1.2, 1.2, 1.2); // Visual feedback
            } else if (selected && hitSquare) {
                const target = hitSquare.object.userData;
                
                // Check for capture
                const targetPiece = pieces.find(p => p.userData.x === target.x && p.userData.z === target.z);
                if (targetPiece && targetPiece.userData.team !== selected.userData.team) {
                    scene.remove(targetPiece);
                    pieces.splice(pieces.indexOf(targetPiece), 1);
                }

                // Move
                selected.userData.x = target.x;
                selected.userData.z = target.z;
                updatePiecePos(selected);
                selected.scale.set(1, 1, 1);
                selected = null;
            }
        });

        // --- Lights ---
        const l1 = new THREE.PointLight(0x00ffff, 50); l1.position.set(5, 5, 5); scene.add(l1);
        const l2 = new THREE.PointLight(0xff00ff, 50); l2.position.set(-5, 5, -5); scene.add(l2);
        camera.position.set(0, 8, 8);
        const controls = new OrbitControls(camera, renderer.domElement);

        function animate(t) {
            requestAnimationFrame(animate);
            const time = t * 0.001;
            pieces.forEach(p => {
                // Bobbing is now relative to their base Y=0.5
                p.position.y = 0.5 + Math.sin(time * 3 + p.userData.x) * 0.05;
                p.rotation.y += 0.01;
            });
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
        const whiteMat = new THREE.MeshPhysicalMaterial({
            transmission: 1, thickness: 1.5, ior: 1.33, color: 0xffffff, attenuationColor: 0x00ffff, roughness: 0.02
        });
        const blackMat = new THREE.MeshPhysicalMaterial({
            transmission: 1, thickness: 1.5, ior: 1.45, color: 0x222222, attenuationColor: 0xff0066, roughness: 0.05
        });

        // --- Board Logic ---
        const boardGroup = new THREE.Group();
        const squares = [];
        for (let x = 0; x < 8; x++) {
            for (let z = 0; z < 8; z++) {
                const geo = new THREE.BoxGeometry(0.95, 0.1, 0.95);
                const mat = new THREE.MeshPhysicalMaterial({ 
                    transparent: true, opacity: 0.2, color: (x + z) % 2 === 0 ? 0xffffff : 0x000000 
                });
                const square = new THREE.Mesh(geo, mat);
                square.position.set(x - 3.5, -0.05, z - 3.5);
                square.userData = { gridX: x, gridZ: z };
                scene.add(square);
                squares.push(square);
            }
        }

        // --- Piece Factory ---
        const geos = {
            pawn: new THREE.SphereGeometry(0.25, 32, 32),
            rook: new THREE.CylinderGeometry(0.3, 0.3, 0.7, 32),
            knight: new THREE.TorusKnotGeometry(0.18, 0.06, 64, 8),
            bishop: new THREE.ConeGeometry(0.25, 0.8, 32),
            queen: new THREE.SphereGeometry(0.4, 6, 6),
            king: new THREE.BoxGeometry(0.4, 1.1, 0.4)
        };

        const pieces = [];
        function spawn(type, x, z, team) {
            const mesh = new THREE.Mesh(geos[type], team === 'white' ? whiteMat.clone() : blackMat.clone());
            mesh.position.set(x - 3.5, 0.5, z - 3.5);
            mesh.userData = { type, team, gridX: x, gridZ: z };
            scene.add(mesh);
            pieces.push(mesh);
        }

        const layout = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
        for(let i=0; i<8; i++) {
            spawn(layout[i], i, 0, 'white'); spawn('pawn', i, 1, 'white');
            spawn(layout[i], i, 7, 'black'); spawn('pawn', i, 6, 'black');
        }

        // --- Raycasting & Interaction ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selected = null;

        window.addEventListener('click', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersectsPieces = raycaster.intersectObjects(pieces);
            const intersectsSquares = raycaster.intersectObjects(squares);

            if (intersectsPieces.length > 0) {
                if (selected) selected.material.emissive.setHex(0x000000);
                selected = intersectsPieces[0].object;
                selected.material.emissive.setHex(0x222222);
                document.getElementById('ui').innerText = `${selected.userData.team} ${selected.userData.type} selected`;
            } else if (selected && intersectsSquares.length > 0) {
                const target = intersectsSquares[0].object.userData;
                
                // Basic Move Logic: check if space is occupied
                const occupant = pieces.find(p => p.userData.gridX === target.gridX && p.userData.gridZ === target.gridZ);
                
                if (occupant && occupant.userData.team !== selected.userData.team) {
                    // Capture
                    scene.remove(occupant);
                    pieces.splice(pieces.indexOf(occupant), 1);
                }

                if (!occupant || occupant.userData.team !== selected.userData.team) {
                    selected.position.x = target.gridX - 3.5;
                    selected.position.z = target.gridZ - 3.5;
                    selected.userData.gridX = target.gridX;
                    selected.userData.gridZ = target.gridZ;
                    selected.material.emissive.setHex(0x000000);
                    selected = null;
                    document.getElementById('ui').innerText = "Piece moved";
                }
            }
        });

        // --- Lighting & Scene Environment ---
        const light1 = new THREE.PointLight(0x00ffff, 40); light1.position.set(5, 5, 5); scene.add(light1);
        const light2 = new THREE.PointLight(0xff00ff, 40); light2.position.set(-5, 5, -5); scene.add(light2);
        camera.position.set(0, 10, 10);
        const controls = new OrbitControls(camera, renderer.domElement);

        function animate(t) {
            requestAnimationFrame(animate);
            const time = t * 0.001;
            pieces.forEach(p => {
                p.position.y = 0.5 + Math.sin(time * 2 + p.position.x) * 0.03;
                p.rotation.y += 0.005;
            });
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
        const genEnv = () => {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(256, 256, 0, 256, 256, 256);
            grad.addColorStop(0, '#112233'); grad.addColorStop(1, '#000000');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 512, 512);
            const tex = new THREE.CanvasTexture(canvas);
            tex.mapping = THREE.EquirectangularReflectionMapping;
            return tex;
        };
        scene.environment = genEnv();

        // --- Materials ---
        const lightMat = new THREE.MeshPhysicalMaterial({
            transmission: 1.0, thickness: 1.5, roughness: 0.02, ior: 1.33,
            color: 0xffffff, attenuationColor: 0x00ffff, attenuationDistance: 0.5, clearcoat: 1.0
        });

        const darkMat = new THREE.MeshPhysicalMaterial({
            transmission: 1.0, thickness: 1.5, roughness: 0.05, ior: 1.45,
            color: 0x222222, attenuationColor: 0xff0066, attenuationDistance: 0.4, clearcoat: 1.0
        });

        // --- Board ---
        const board = new THREE.Mesh(
            new THREE.BoxGeometry(8.5, 0.4, 8.5),
            new THREE.MeshPhysicalMaterial({ transmission: 0.9, roughness: 0.1, thickness: 1, color: 0xffffff })
        );
        board.position.y = -0.25;
        scene.add(board);
        scene.add(new THREE.GridHelper(8, 8, 0x00ffff, 0x333333));

        // --- Geometries ---
        const geos = {
            pawn: new THREE.SphereGeometry(0.3, 32, 32),
            rook: new THREE.BoxGeometry(0.5, 0.7, 0.5),
            knight: new THREE.TorusKnotGeometry(0.2, 0.07, 64, 8),
            bishop: new THREE.ConeGeometry(0.3, 0.9, 32),
            queen: new THREE.OctahedronGeometry(0.5, 0),
            king: new THREE.CylinderGeometry(0.25, 0.4, 1.2, 4)
        };

        const pieces = [];
        const spawnPiece = (type, x, z, mat) => {
            const piece = new THREE.Mesh(geos[type], mat.clone());
            piece.userData = { type, baseHeight: 0.5, originalColor: mat.color.getHex() };
            piece.position.set(x - 3.5, 0.5, z - 3.5);
            scene.add(piece);
            pieces.push(piece);
        };

        const layout = ['rook', 'knight', 'bishop', 'queen', 'king', 'bishop', 'knight', 'rook'];
        for (let i = 0; i < 8; i++) {
            spawnPiece(layout[i], i, 0, lightMat);
            spawnPiece('pawn', i, 1, lightMat);
            spawnPiece(layout[i], i, 7, darkMat);
            spawnPiece('pawn', i, 6, darkMat);
        }

        // --- Interaction Logic ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selected = null;

        window.addEventListener('mousedown', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(pieces);
            if (intersects.length > 0) {
                if (selected) selected.material.emissive.setHex(0x000000);
                selected = intersects[0].object;
                selected.material.emissive.setHex(0x00ffff); // Glow when selected
                selected.position.y = 0.8; // Lift slightly
            }
        });

        // --- Lights ---
        const p1 = new THREE.PointLight(0x00ffff, 50); p1.position.set(5, 5, 5); scene.add(p1);
        const p2 = new THREE.PointLight(0xff00ff, 30); p2.position.set(-5, 5, -5); scene.add(p2);

        camera.position.set(0, 10, 10);
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        function animate(t) {
            requestAnimationFrame(animate);
            const time = t * 0.001;
            
            pieces.forEach(p => {
                // Fixed Animation: Bobbing without accumulation
                const offset = Math.sin(time * 2 + p.position.x) * 0.05;
                const targetY = (p === selected) ? 0.8 : 0.5;
                p.position.y = targetY + offset;
                p.rotation.y += 0.01;
            });

            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>

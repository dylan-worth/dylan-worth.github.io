<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dragon Wilds: Dense Forest</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffff00;
            text-shadow: 1px 1px #000;
            pointer-events: none;
            z-index: 10;
        }

        #controls-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 150px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        #joystick-zone {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            pointer-events: auto;
            position: relative;
        }
        #joystick-nipple {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .btn-group {
            display: flex;
            gap: 15px;
            pointer-events: auto;
            padding-bottom: 10px;
        }
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid #ccc;
            background: rgba(0,0,0,0.5);
            color: white;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            cursor: pointer;
        }
        #btn-axe { background: linear-gradient(135deg, #4b0082, #800080); border-color: #d8bfd8; }
        #btn-jump { background: linear-gradient(135deg, #228b22, #32cd32); border-color: #90ee90; }

    </style>
</head>
<body>

<div id="ui-layer">
    <h3 style="margin: 0;">Deep Forest</h3>
    <div>Tap Axe to chop â€¢ Find the Fox!</div>
</div>

<div id="controls-container">
    <div id="joystick-zone"><div id="joystick-nipple"></div></div>
    
    <div class="btn-group">
        <div id="btn-axe" class="action-btn">THROW<br>AXE</div>
        <div id="btn-jump" class="action-btn">JUMP</div>
    </div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.minDistance = 5;
    controls.maxDistance = 40;
    controls.maxPolarAngle = Math.PI / 2.1;

    // Environment
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xfff0dd, 1.2);
    sun.position.set(30, 50, 20);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048; 
    sun.shadow.mapSize.height = 2048;
    scene.add(sun);

    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 300),
        new THREE.MeshStandardMaterial({ color: 0x3a7e2c })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- 2. DENSE FOREST ---
    const trees = [];
    const treeGeo = new THREE.ConeGeometry(2.5, 7, 7);
    const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 2, 6);
    const treeMat = new THREE.MeshStandardMaterial({ color: 0x1e6b22 });
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });

    function spawnTree(x, z) {
        const grp = new THREE.Group();
        const t = new THREE.Mesh(trunkGeo, trunkMat); t.position.y=1; t.castShadow=true; grp.add(t);
        const l = new THREE.Mesh(treeGeo, treeMat); l.position.y=4.5; l.castShadow=true; grp.add(l);
        
        // Randomize size slightly
        const s = 0.8 + Math.random()*0.6;
        grp.scale.set(s,s,s);
        grp.position.set(x, 0, z);
        grp.userData = { hp: 1 }; // For cutting logic
        
        scene.add(grp);
        trees.push(grp);
    }

    // Spawn 120 Trees (Dense!)
    for(let i=0; i<120; i++) {
        const x = (Math.random()-0.5)*200; 
        const z = (Math.random()-0.5)*200;
        // Keep a clear area in middle (0,0)
        if(Math.abs(x)>8 || Math.abs(z)>8) spawnTree(x, z);
    }

    // --- 3. PLAYER ---
    const playerGroup = new THREE.Group();
    scene.add(playerGroup);

    const charBody = new THREE.Group();
    const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.6), new THREE.MeshStandardMaterial({ color: 0x336699 }));
    torso.position.y = 2.25; torso.castShadow = true; charBody.add(torso);
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({ color: 0xf5cca8 }));
    head.position.y = 3.3; charBody.add(head);

    function createLimb(x, y, color) {
        const p = new THREE.Group(); p.position.set(x, y, 0);
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), new THREE.MeshStandardMaterial({ color: color }));
        m.position.y = -0.6; m.castShadow = true; p.add(m);
        return p;
    }
    const lArm = createLimb(-0.7, 2.8, 0x336699); charBody.add(lArm);
    const rArm = createLimb(0.7, 2.8, 0x336699); charBody.add(rArm);
    const lLeg = createLimb(-0.3, 1.5, 0x555555); charBody.add(lLeg);
    const rLeg = createLimb(0.3, 1.5, 0x555555); charBody.add(rLeg);
    playerGroup.add(charBody);

    // --- 4. UPDATED FOX (Box Nose + White Ball Tail) ---
    const foxGroup = new THREE.Group();
    foxGroup.position.set(5, 0, 5);
    scene.add(foxGroup);

    const fBodyMat = new THREE.MeshStandardMaterial({ color: 0xd9580d }); // Orange
    const fWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White
    const fDarkMat = new THREE.MeshStandardMaterial({ color: 0x221100 }); 

    // Body
    const fBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 2.5), fBodyMat);
    fBody.position.y = 1; fBody.castShadow = true;
    foxGroup.add(fBody);

    // Head
    const fHeadGroup = new THREE.Group();
    fHeadGroup.position.set(0, 1.6, 1.3);
    const fHeadMain = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.8, 1), fBodyMat);
    fHeadGroup.add(fHeadMain);
    
    // RECTANGLE NOSE (Box)
    const fSnout = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.6), fWhiteMat);
    fSnout.position.set(0, -0.1, 0.7);
    fHeadGroup.add(fSnout);
    
    // Ears
    const earGeo = new THREE.ConeGeometry(0.15, 0.4, 4);
    const lEar = new THREE.Mesh(earGeo, fDarkMat); lEar.position.set(-0.3, 0.6, 0); lEar.rotation.y = -0.2;
    const rEar = new THREE.Mesh(earGeo, fDarkMat); rEar.position.set(0.3, 0.6, 0); rEar.rotation.y = 0.2;
    fHeadGroup.add(lEar); fHeadGroup.add(rEar);
    foxGroup.add(fHeadGroup);

    // Tail
    const fTail = new THREE.Group();
    fTail.position.set(0, 1.2, -1.2);
    const tailMain = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.25, 1.2), fBodyMat);
    tailMain.rotation.x = -Math.PI/4; tailMain.position.y = 0.4; tailMain.position.z = -0.4;
    fTail.add(tailMain);
    
    // WHITE BALL TAIL TIP
    const tailTip = new THREE.Mesh(new THREE.SphereGeometry(0.35, 8, 8), fWhiteMat);
    tailTip.position.set(0, 0.8, -0.8);
    fTail.add(tailTip);
    foxGroup.add(fTail);

    // Legs
    const fLegs = [];
    function createFoxLeg(x, z) {
        const l = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1, 0.25), fDarkMat);
        l.position.set(x, 0.5, z);
        foxGroup.add(l);
        fLegs.push(l);
    }
    createFoxLeg(-0.4, 1); createFoxLeg(0.4, 1); createFoxLeg(-0.4, -1); createFoxLeg(0.4, -1);


    // --- 5. CONTROLS (Joystick + Axe + Jump) ---
    const joyZone = document.getElementById('joystick-zone');
    const joyNip = document.getElementById('joystick-nipple');
    const moveVector = new THREE.Vector2(0,0);
    let joyId = null;

    // Joystick Touch
    joyZone.addEventListener('touchstart', e => {
        e.preventDefault();
        if(joyId !== null) return;
        joyId = e.changedTouches[0].identifier;
        handleJoy(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    });

    joyZone.addEventListener('touchmove', e => {
        e.preventDefault();
        for(let t of e.changedTouches) if(t.identifier === joyId) handleJoy(t.clientX, t.clientY);
    });

    const endJoy = () => { joyId=null; moveVector.set(0,0); joyNip.style.transform=`translate(-50%,-50%)`; };
    joyZone.addEventListener('touchend', endJoy); joyZone.addEventListener('touchcancel', endJoy);

    function handleJoy(x, y) {
        const rect = joyZone.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        let dx = x - cx, dy = y - cy;
        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
        const ang = Math.atan2(dy, dx);
        dx = Math.cos(ang)*dist; dy = Math.sin(ang)*dist;
        joyNip.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        
        // Output -1 to 1
        moveVector.x = dx/50; 
        moveVector.y = dy/50; 
    }

    // Jump & Axe
    let jumpVel = 0;
    const projectiles = [];
    
    document.getElementById('btn-jump').addEventListener('pointerdown', (e) => {
        e.preventDefault();
        if(playerGroup.position.y <= 0) jumpVel = 0.4;
    });

    document.getElementById('btn-axe').addEventListener('pointerdown', (e) => {
        e.preventDefault();
        spawnAxe();
    });

    function spawnAxe() {
        const ag = new THREE.Group();
        // Visuals
        const handle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 0.1), new THREE.MeshStandardMaterial({color: 0x654321}));
        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.1), new THREE.MeshStandardMaterial({color: 0xaaaaaa, emissive: 0x00ffff, emissiveIntensity: 0.5}));
        blade.position.set(0, 0.5, 0);
        ag.add(handle); ag.add(blade);
        ag.add(new THREE.PointLight(0x00ffff, 1, 4));

        ag.position.copy(playerGroup.position);
        ag.position.y += 2.5;
        
        const dir = new THREE.Vector3(0,0,1).applyQuaternion(playerGroup.quaternion);
        projectiles.push({ mesh: ag, dir: dir, life: 100 });
        scene.add(ag);
    }

    // --- 6. ANIMATION LOOP ---
    // Fox AI Vars
    let foxState = "wander"; 
    let foxTimer = 0; 
    let foxTarget = new THREE.Vector3();
    const particles = [];

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // --- PLAYER MOVEMENT (Camera Relative) ---
        if(moveVector.lengthSq() > 0.01) {
            // Get camera Forward vector (projected on XZ plane)
            const camForward = new THREE.Vector3();
            camera.getWorldDirection(camForward);
            camForward.y = 0;
            camForward.normalize();

            // Get camera Right vector
            const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Object3D().up).normalize();

            // Calculate Move Direction based on Joystick
            // JoyY < 0 (Up) means move along camForward
            // JoyY > 0 (Down) means move along -camForward
            // JoyX > 0 (Right) means move along camRight
            
            const moveDir = new THREE.Vector3();
            moveDir.addScaledVector(camForward, -moveVector.y); // Invert Y because Screen Y is down
            moveDir.addScaledVector(camRight, moveVector.x);

            if(moveDir.lengthSq() > 0) {
                moveDir.normalize();
                const speed = 10 * delta;
                playerGroup.position.add(moveDir.multiplyScalar(speed));
                
                // Rotate to face travel direction
                const targetRot = Math.atan2(moveDir.x, moveDir.z);
                playerGroup.rotation.y = targetRot;

                // Animation
                const f = 12; 
                lLeg.rotation.x = Math.sin(time*f)*0.8; rLeg.rotation.x = Math.sin(time*f + Math.PI)*0.8;
                lArm.rotation.x = Math.sin(time*f + Math.PI)*0.8; rArm.rotation.x = Math.sin(time*f)*0.8;
            }
        } else {
            lLeg.rotation.x = rLeg.rotation.x = lArm.rotation.x = rArm.rotation.x = 0;
        }

        // --- JUMP PHYSICS ---
        if(jumpVel > 0 || playerGroup.position.y > 0) {
            playerGroup.position.y += jumpVel;
            jumpVel -= 0.02;
            if(playerGroup.position.y < 0) { playerGroup.position.y = 0; jumpVel = 0; }
        }

        // --- FOX AI ---
        foxTimer -= delta;
        if (foxState === "wander") {
            foxGroup.rotation.x = THREE.MathUtils.lerp(foxGroup.rotation.x, 0, 0.1);
            if (foxTimer < 0) {
                foxTarget.set((Math.random()-0.5)*60, 0, (Math.random()-0.5)*60);
                foxTimer = 3 + Math.random()*4;
                if(Math.random() > 0.6) foxState = "dig";
            }
            const dir = new THREE.Vector3().subVectors(foxTarget, foxGroup.position);
            if(dir.length() > 1) {
                dir.normalize();
                foxGroup.position.add(dir.multiplyScalar(5 * delta));
                foxGroup.lookAt(foxTarget);
                const ls = 15;
                fLegs[0].rotation.x = Math.sin(time*ls)*0.4; fLegs[1].rotation.x = Math.sin(time*ls+Math.PI)*0.4;
                fLegs[2].rotation.x = Math.sin(time*ls+Math.PI)*0.4; fLegs[3].rotation.x = Math.sin(time*ls)*0.4;
            }
        } else if (foxState === "dig") {
            if(foxTimer <= 0) { foxState = "wander"; foxTimer = 2; }
            foxGroup.rotation.x = THREE.MathUtils.lerp(foxGroup.rotation.x, 0.5, 0.1);
            fLegs[0].rotation.x = Math.sin(time*30)*0.8; fLegs[1].rotation.x = Math.cos(time*30)*0.8;
            // Particles
            if(Math.random() > 0.8) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color: 0x3d2817}));
                const offset = new THREE.Vector3(0,0,1.5).applyQuaternion(foxGroup.quaternion);
                p.position.copy(foxGroup.position).add(offset);
                particles.push({mesh:p, vel: new THREE.Vector3((Math.random()-0.5),1,(Math.random()-0.5)).multiplyScalar(0.2), life: 30});
                scene.add(p);
            }
        }

        // --- PROJECTILES & TREES ---
        for(let i=projectiles.length-1; i>=0; i--) {
            const p = projectiles[i];
            p.mesh.position.add(p.dir.clone().multiplyScalar(0.6));
            p.mesh.rotation.z -= 0.5;
            p.life--;
            
            // Check Collision
            let hit = false;
            for(let j=trees.length-1; j>=0; j--) {
                if(trees[j].userData.hp > 0 && p.mesh.position.distanceTo(trees[j].position) < 3) {
                    trees[j].userData.hp = 0;
                    // Fall anim
                    const t = trees[j];
                    const fall = setInterval(()=>{
                        t.rotation.x += 0.05; t.position.y -= 0.1; t.scale.multiplyScalar(0.95);
                        if(t.scale.x < 0.1) { clearInterval(fall); scene.remove(t); }
                    }, 20);
                    hit = true; break;
                }
            }
            if(p.life<=0 || hit) { scene.remove(p.mesh); projectiles.splice(i,1); }
        }

        // --- PARTICLES ---
        for(let i=particles.length-1; i>=0; i--) {
            const p = particles[i];
            p.mesh.position.add(p.vel);
            p.vel.y -= 0.01; p.life--;
            if(p.life<=0) { scene.remove(p.mesh); particles.splice(i,1); }
        }

        // Camera Follow
        controls.target.copy(playerGroup.position);
        controls.target.y = 1;
        controls.update();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>

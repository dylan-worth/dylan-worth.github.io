<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Runescape Style: Fox Update</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffff00;
            text-shadow: 1px 1px #000;
            pointer-events: none;
            z-index: 10;
        }

        #controls-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 150px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        #joystick-zone {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            pointer-events: auto;
            position: relative;
        }
        #joystick-nipple {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0,0,0,0.5);
            color: white;
            border: 3px solid #ccc;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            pointer-events: auto;
            cursor: pointer;
        }
        #btn-jump { background: linear-gradient(135deg, #228b22, #32cd32); }
    </style>
</head>
<body>

<div id="ui-layer">
    <h3 style="margin: 0;">Wild Woods</h3>
    <div>Zoom enabled â€¢ Watch the Fox dig!</div>
</div>

<div id="controls-container">
    <div id="joystick-zone"><div id="joystick-nipple"></div></div>
    <div id="btn-jump" class="action-btn">JUMP</div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. SCENE SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, 90);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Controls - Enable Zoom
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.minDistance = 5;  // Minimum zoom
    controls.maxDistance = 40; // Maximum zoom
    controls.maxPolarAngle = Math.PI / 2.1; // Prevent going under ground

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xfff0dd, 1.2);
    sun.position.set(30, 50, 20);
    sun.castShadow = true;
    scene.add(sun);

    // Ground
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshStandardMaterial({ color: 0x3a7e2c })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Scenery
    const treeGeo = new THREE.ConeGeometry(2, 6, 8);
    const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 2, 6);
    const treeMat = new THREE.MeshStandardMaterial({ color: 0x1e6b22 });
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });

    for(let i=0; i<30; i++) {
        const x = (Math.random()-0.5)*150; 
        const z = (Math.random()-0.5)*150;
        if(Math.abs(x)>5 || Math.abs(z)>5) {
            const grp = new THREE.Group();
            const t = new THREE.Mesh(trunkGeo,trunkMat); t.position.y=1; t.castShadow=true; grp.add(t);
            const l = new THREE.Mesh(treeGeo,treeMat); l.position.y=4; l.castShadow=true; grp.add(l);
            grp.position.set(x,0,z);
            scene.add(grp);
        }
    }

    // --- 2. PLAYER (Constructed) ---
    const playerGroup = new THREE.Group();
    scene.add(playerGroup);

    const charBody = new THREE.Group();
    const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.6), new THREE.MeshStandardMaterial({ color: 0x336699 }));
    torso.position.y = 2.25; torso.castShadow = true; charBody.add(torso);
    
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({ color: 0xf5cca8 }));
    head.position.y = 3.3; charBody.add(head);

    function createLimb(x, y, color) {
        const p = new THREE.Group(); p.position.set(x, y, 0);
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), new THREE.MeshStandardMaterial({ color: color }));
        m.position.y = -0.6; m.castShadow = true; p.add(m);
        return p;
    }
    const lArm = createLimb(-0.7, 2.8, 0x336699); charBody.add(lArm);
    const rArm = createLimb(0.7, 2.8, 0x336699); charBody.add(rArm);
    const lLeg = createLimb(-0.3, 1.5, 0x555555); charBody.add(lLeg);
    const rLeg = createLimb(0.3, 1.5, 0x555555); charBody.add(rLeg);
    playerGroup.add(charBody);

    // --- 3. THE FOX (Geometric) ---
    const foxGroup = new THREE.Group();
    foxGroup.position.set(10, 0, 10);
    scene.add(foxGroup);

    // Fox Body
    const fBodyMat = new THREE.MeshStandardMaterial({ color: 0xd9580d }); // Orange
    const fWhiteMat = new THREE.MeshStandardMaterial({ color: 0xdddddd }); // White tips
    const fDarkMat = new THREE.MeshStandardMaterial({ color: 0x221100 }); // Paws/Ears

    const fBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 2.5), fBodyMat);
    fBody.position.y = 1; 
    fBody.castShadow = true;
    foxGroup.add(fBody);

    // Fox Head
    const fHeadGroup = new THREE.Group();
    fHeadGroup.position.set(0, 1.6, 1.3);
    const fHeadMain = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.8, 1), fBodyMat);
    fHeadGroup.add(fHeadMain);
    // Snout
    const fSnout = new THREE.Mesh(new THREE.ConeGeometry(0.3, 0.8, 4), fWhiteMat);
    fSnout.rotation.x = Math.PI/2;
    fSnout.rotation.y = Math.PI/4;
    fSnout.position.z = 0.8;
    fHeadGroup.add(fSnout);
    // Ears
    const earGeo = new THREE.ConeGeometry(0.15, 0.4, 4);
    const lEar = new THREE.Mesh(earGeo, fDarkMat); lEar.position.set(-0.3, 0.6, 0); lEar.rotation.y = -0.2;
    const rEar = new THREE.Mesh(earGeo, fDarkMat); rEar.position.set(0.3, 0.6, 0); rEar.rotation.y = 0.2;
    fHeadGroup.add(lEar); fHeadGroup.add(rEar);
    foxGroup.add(fHeadGroup);

    // Fox Tail
    const fTail = new THREE.Group();
    fTail.position.set(0, 1.2, -1.2);
    const tailMain = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.3, 1.5), fBodyMat);
    tailMain.rotation.x = -Math.PI/4; tailMain.position.y = 0.5; tailMain.position.z = -0.5;
    fTail.add(tailMain);
    const tailTip = new THREE.Mesh(new THREE.SphereGeometry(0.3), fWhiteMat);
    tailTip.position.set(0, 1.0, -1.0);
    fTail.add(tailTip);
    foxGroup.add(fTail);

    // Fox Legs
    const fLegs = [];
    function createFoxLeg(x, z) {
        const l = new THREE.Mesh(new THREE.BoxGeometry(0.25, 1, 0.25), fDarkMat);
        l.position.set(x, 0.5, z);
        foxGroup.add(l);
        fLegs.push(l);
    }
    createFoxLeg(-0.4, 1); // Front L
    createFoxLeg(0.4, 1);  // Front R
    createFoxLeg(-0.4, -1); // Back L
    createFoxLeg(0.4, -1);  // Back R


    // --- 4. JOYSTICK LOGIC (FIXED) ---
    const joyZone = document.getElementById('joystick-zone');
    const joyNip = document.getElementById('joystick-nipple');
    let moveVector = new THREE.Vector2(0,0);
    let joyId = null;

    joyZone.addEventListener('touchstart', e => {
        e.preventDefault();
        if(joyId !== null) return;
        joyId = e.changedTouches[0].identifier;
        handleJoy(e.changedTouches[0].clientX, e.changedTouches[0].clientY);
    });

    joyZone.addEventListener('touchmove', e => {
        e.preventDefault();
        for(let t of e.changedTouches) if(t.identifier === joyId) handleJoy(t.clientX, t.clientY);
    });

    const endJoy = () => { joyId=null; moveVector.set(0,0); joyNip.style.transform=`translate(-50%,-50%)`; };
    joyZone.addEventListener('touchend', endJoy); 
    joyZone.addEventListener('touchcancel', endJoy);

    function handleJoy(x, y) {
        const rect = joyZone.getBoundingClientRect();
        const cx = rect.left + rect.width/2;
        const cy = rect.top + rect.height/2;
        let dx = x - cx, dy = y - cy;
        const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
        const ang = Math.atan2(dy, dx);
        dx = Math.cos(ang)*dist; dy = Math.sin(ang)*dist;
        joyNip.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        
        // FIX: Invert Y here. -1 is Up (Forward), 1 is Down (Back)
        moveVector.x = dx/50; 
        moveVector.y = dy/50; 
    }

    // --- 5. GAME LOGIC ---
    let jumpVel = 0;
    document.getElementById('btn-jump').addEventListener('pointerdown', () => { if(playerGroup.position.y<=0) jumpVel = 0.4; });

    // Fox AI Variables
    let foxState = "wander"; // wander, dig
    let foxTimer = 0;
    let foxTarget = new THREE.Vector3();
    const particles = [];

    function updateFox(delta, time) {
        foxTimer -= delta;

        if (foxState === "wander") {
            // Restore rotation from dig
            foxGroup.rotation.x = THREE.MathUtils.lerp(foxGroup.rotation.x, 0, 0.1);

            // Move
            if (foxTimer < 0) {
                // Pick new spot
                foxTarget.set((Math.random()-0.5)*40, 0, (Math.random()-0.5)*40);
                foxTimer = 3 + Math.random()*4;
                if(Math.random() > 0.6) foxState = "dig"; // Chance to dig
            }
            
            // Walk to target
            const dir = new THREE.Vector3().subVectors(foxTarget, foxGroup.position);
            if(dir.length() > 1) {
                dir.normalize();
                foxGroup.position.add(dir.multiplyScalar(4 * delta)); // Speed
                foxGroup.lookAt(foxTarget);
                
                // Leg Animation
                const legSpeed = 15;
                fLegs[0].rotation.x = Math.sin(time*legSpeed)*0.4;
                fLegs[1].rotation.x = Math.sin(time*legSpeed + Math.PI)*0.4;
                fLegs[2].rotation.x = Math.sin(time*legSpeed + Math.PI)*0.4;
                fLegs[3].rotation.x = Math.sin(time*legSpeed)*0.4;
            } else {
                // Idle
                fLegs.forEach(l => l.rotation.x = 0);
            }

        } else if (foxState === "dig") {
            if(foxTimer <= 0) { foxState = "wander"; foxTimer = 2; return; }

            // Dig Animation
            foxGroup.rotation.x = THREE.MathUtils.lerp(foxGroup.rotation.x, 0.5, 0.1); // Tilt down
            
            // Frantic leg movement
            const digSpeed = 30;
            fLegs[0].rotation.x = Math.sin(time*digSpeed)*0.8;
            fLegs[1].rotation.x = Math.cos(time*digSpeed)*0.8;

            // Spawn Particles
            if(Math.random() > 0.8) {
                const p = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color: 0x3d2817}));
                // Spawn at paws
                const offset = new THREE.Vector3(0, 0, 1.5).applyQuaternion(foxGroup.quaternion);
                p.position.copy(foxGroup.position).add(offset);
                
                // Velocity
                const vel = new THREE.Vector3((Math.random()-0.5), 1, (Math.random()-0.5)).normalize().multiplyScalar(0.2);
                particles.push({mesh:p, vel:vel, life: 30});
                scene.add(p);
            }
        }
    }

    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // 1. Player Move
        if(moveVector.lengthSq() > 0.01) {
            // Camera Direction
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const camAngle = Math.atan2(camDir.x, camDir.z);
            
            // Joy Angle: "Up" (Neg Y) means Go Forward (0 deg relative)
            // So we need to flip Y for the calculation or subtract PI/2. 
            // Simple method: Joy X is right/left. Joy Y is Back/Forward.
            // Screen Y+ is Down. So JoyY > 0 is Back. JoyY < 0 is Forward.
            // atan2(y, x). 
            
            const joyAngle = Math.atan2(moveVector.x, moveVector.y);
            const moveDir = joyAngle + camAngle;

            const speed = 8 * delta;
            playerGroup.position.x += Math.sin(moveDir) * speed;
            playerGroup.position.z += Math.cos(moveDir) * speed;
            playerGroup.rotation.y = moveDir;

            // Run Anim
            const f = 12; 
            lLeg.rotation.x = Math.sin(time*f)*0.8; rLeg.rotation.x = Math.sin(time*f + Math.PI)*0.8;
            lArm.rotation.x = Math.sin(time*f + Math.PI)*0.8; rArm.rotation.x = Math.sin(time*f)*0.8;
        } else {
            lLeg.rotation.x = rLeg.rotation.x = lArm.rotation.x = rArm.rotation.x = 0;
        }

        // Jump
        if(jumpVel > 0 || playerGroup.position.y > 0) {
            playerGroup.position.y += jumpVel;
            jumpVel -= 0.02;
            if(playerGroup.position.y < 0) { playerGroup.position.y = 0; jumpVel = 0; }
        }

        // 2. Fox Logic
        updateFox(delta, time);

        // 3. Particles
        for(let i=particles.length-1; i>=0; i--) {
            const p = particles[i];
            p.mesh.position.add(p.vel);
            p.vel.y -= 0.01; // Gravity
            p.life--;
            if(p.life<=0) { scene.remove(p.mesh); particles.splice(i,1); }
        }

        // 4. Camera Follows Player (But allows zoom)
        controls.target.copy(playerGroup.position);
        controls.target.y = 1; // Look at center of body
        controls.update();

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>

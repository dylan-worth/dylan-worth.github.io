<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RS: Dragon Wilds Survival</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Verdana', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* --- UI LAYOUT --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }

        /* 1. MINIMAP */
        #minimap-container {
            position: absolute; top: 10px; right: 10px;
            width: 120px; height: 120px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #5d5d5d;
            border-radius: 50%;
            overflow: hidden;
        }
        #minimap-canvas { width: 100%; height: 100%; }

        /* 2. SURVIVAL HUD */
        #stats-panel {
            position: absolute; top: 10px; left: 10px;
            display: flex; flex-direction: column; gap: 5px;
        }
        .stat-bar {
            width: 150px; height: 18px;
            background: #333; border: 1px solid #000;
            position: relative;
        }
        .bar-fill { height: 100%; transition: width 0.2s; }
        #hp-fill { background: #d63031; width: 100%; }
        #run-fill { background: #fdcb6e; width: 100%; }
        .stat-icon {
            position: absolute; top: 0; left: 4px; font-size: 12px; color: #fff; line-height: 18px; text-shadow: 1px 1px 0 #000;
        }

        /* 3. INVENTORY */
        #inventory {
            position: absolute; bottom: 180px; right: 10px;
            display: grid; grid-template-columns: repeat(2, 1fr); gap: 4px;
        }
        .inv-slot {
            width: 40px; height: 40px;
            background: #3e3e3e; border: 2px inset #5a5a5a;
            display: flex; justify-content: center; align-items: center;
        }
        .inv-item { width: 30px; height: 30px; border-radius: 4px; }
        .log-item { background: #654321; box-shadow: inset 2px 2px #8b5a2b; }

        /* XP DROPS */
        .xp-drop {
            position: absolute; color: #fb1; font-weight: bold; font-size: 18px;
            text-shadow: 1px 1px 0 #000; pointer-events: none;
            animation: floatUp 1.5s forwards;
        }
        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }

        /* CONTROLS */
        #controls-container {
            position: absolute; bottom: 20px; left: 20px; right: 20px; height: 150px;
            pointer-events: none; display: flex; justify-content: space-between; align-items: flex-end;
        }
        #joystick-zone {
            width: 120px; height: 120px;
            background: rgba(255,255,255,0.15);
            border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);
            pointer-events: auto; position: relative;
        }
        #joystick-nipple {
            position: absolute; top: 50%; left: 50%;
            width: 50px; height: 50px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%; transform: translate(-50%, -50%);
        }
        .btn-group { display: flex; gap: 15px; pointer-events: auto; padding-bottom: 10px; }
        .action-btn {
            width: 70px; height: 70px; border-radius: 50%;
            border: 3px solid #777; background: rgba(0,0,0,0.6);
            color: white; font-weight: bold; font-size: 12px;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            text-align: center; cursor: pointer;
        }
        #btn-axe { border-color: #a29bfe; }
        #btn-jump { border-color: #55efc4; }

    </style>
</head>
<body>

<div id="ui-layer">
    <div id="stats-panel">
        <div class="stat-bar"><div id="hp-fill" class="bar-fill"></div><span class="stat-icon">HP</span></div>
        <div class="stat-bar"><div id="run-fill" class="bar-fill"></div><span class="stat-icon">RUN</span></div>
    </div>

    <div id="minimap-container">
        <canvas id="minimap-canvas" width="120" height="120"></canvas>
    </div>

    <div id="inventory">
        <div class="inv-slot" id="slot-0"></div>
        <div class="inv-slot" id="slot-1"></div>
        <div class="inv-slot" id="slot-2"></div>
        <div class="inv-slot" id="slot-3"></div>
    </div>
</div>

<div id="controls-container">
    <div id="joystick-zone"><div id="joystick-nipple"></div></div>
    <div class="btn-group">
        <div id="btn-axe" class="action-btn"><span>THROW</span><span>AXE</span></div>
        <div id="btn-jump" class="action-btn"><span>JUMP</span></div>
    </div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. SETUP & ENVIRONMENT ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, 90);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.minDistance = 5;
    controls.maxDistance = 30;
    controls.maxPolarAngle = Math.PI / 2.1;

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xfff0dd, 1.2);
    sun.position.set(50, 80, 50);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
    scene.add(sun);

    // Ground
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(300, 300),
        new THREE.MeshStandardMaterial({ color: 0x2e8b57 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- 2. OBJECTS (Trees, Player, Fox, Dragon) ---
    
    // Trees
    const trees = [];
    const treeGeo = new THREE.ConeGeometry(2.5, 7, 7);
    const trunkGeo = new THREE.CylinderGeometry(0.5, 0.8, 2, 6);
    const treeMat = new THREE.MeshStandardMaterial({ color: 0x155e19 }); // Darker Green
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });

    function spawnTree(x, z) {
        const grp = new THREE.Group();
        const t = new THREE.Mesh(trunkGeo, trunkMat); t.position.y=1; t.castShadow=true; grp.add(t);
        const l = new THREE.Mesh(treeGeo, treeMat); l.position.y=4.5; l.castShadow=true; grp.add(l);
        grp.position.set(x, 0, z);
        grp.scale.setScalar(0.8 + Math.random()*0.5);
        grp.userData = { hp: 1 };
        scene.add(grp);
        trees.push(grp);
    }

    for(let i=0; i<100; i++) {
        const x = (Math.random()-0.5)*200; 
        const z = (Math.random()-0.5)*200;
        if(Math.abs(x)>10 || Math.abs(z)>10) spawnTree(x, z);
    }

    // Player
    const playerGroup = new THREE.Group();
    scene.add(playerGroup);
    const charBody = new THREE.Group();
    const torso = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.6), new THREE.MeshStandardMaterial({ color: 0x336699 }));
    torso.position.y = 2.25; torso.castShadow = true; charBody.add(torso);
    const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({ color: 0xf5cca8 }));
    head.position.y = 3.3; charBody.add(head);
    function createLimb(x, y, color) {
        const p = new THREE.Group(); p.position.set(x, y, 0);
        const m = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 0.3), new THREE.MeshStandardMaterial({ color: color }));
        m.position.y = -0.6; m.castShadow = true; p.add(m);
        return p;
    }
    const lArm = createLimb(-0.7, 2.8, 0x336699); charBody.add(lArm);
    const rArm = createLimb(0.7, 2.8, 0x336699); charBody.add(rArm);
    const lLeg = createLimb(-0.3, 1.5, 0x555555); charBody.add(lLeg);
    const rLeg = createLimb(0.3, 1.5, 0x555555); charBody.add(rLeg);
    playerGroup.add(charBody);

    // Fox
    const foxGroup = new THREE.Group();
    foxGroup.position.set(5, 0, 5);
    scene.add(foxGroup);
    const fMat = new THREE.MeshStandardMaterial({ color: 0xd9580d });
    const fWht = new THREE.MeshStandardMaterial({ color: 0xffffff });
    const fBlk = new THREE.MeshStandardMaterial({ color: 0x221100 });
    const fBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 2.5), fMat); fBody.position.y=1; foxGroup.add(fBody);
    const fHead = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.8, 1), fMat); fHead.position.set(0,1.6,1.3); foxGroup.add(fHead);
    const fNose = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.6), fWht); fNose.position.set(0,1.5,2.0); foxGroup.add(fNose);
    const fTail = new THREE.Group(); fTail.position.set(0,1.2,-1.2); 
    fTail.add(new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.25,1.2), fMat));
    const tip = new THREE.Mesh(new THREE.SphereGeometry(0.35), fWht); tip.position.y=0.8; fTail.add(tip);
    fTail.rotation.x = -0.8; foxGroup.add(fTail);
    const fLegs = [];
    [[-0.4,1], [0.4,1], [-0.4,-1], [0.4,-1]].forEach(p=>{
        const l=new THREE.Mesh(new THREE.BoxGeometry(0.25,1,0.25), fBlk); l.position.set(p[0],0.5,p[1]); foxGroup.add(l); fLegs.push(l);
    });

    // --- NEW FEATURE 1: GREEN DRAGON ---
    const dragonGroup = new THREE.Group();
    dragonGroup.position.set(-20, 0, -20);
    scene.add(dragonGroup);
    
    // Dragon Geometry
    const dSkin = new THREE.MeshStandardMaterial({ color: 0x2ecc71 }); // Dragon Green
    const dBelly = new THREE.MeshStandardMaterial({ color: 0xf1c40f }); // Yellow
    // Body
    const dBody = new THREE.Mesh(new THREE.BoxGeometry(2, 2.5, 5), dSkin);
    dBody.position.y = 2.5; dragonGroup.add(dBody);
    // Head
    const dHead = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 2.5), dSkin);
    dHead.position.set(0, 4.5, 3.5); dragonGroup.add(dHead);
    // Wings
    const dWingL = new THREE.Mesh(new THREE.BoxGeometry(6, 0.2, 3), dSkin); dWingL.position.set(-3.5, 4, 1); dragonGroup.add(dWingL);
    const dWingR = new THREE.Mesh(new THREE.BoxGeometry(6, 0.2, 3), dSkin); dWingR.position.set(3.5, 4, 1); dragonGroup.add(dWingR);
    // Tail
    const dTail = new THREE.Mesh(new THREE.ConeGeometry(1, 6, 4), dSkin); 
    dTail.rotation.x = -1.2; dTail.position.set(0, 2, -4); dragonGroup.add(dTail);

    // --- 3. GAME STATE & LOGIC ---
    let hp = 100;
    let runEnergy = 100;
    let inventory = 0;
    const projectiles = [];
    const particles = [];

    // --- UI UPDATES ---
    function updateHUD() {
        document.getElementById('hp-fill').style.width = hp + '%';
        document.getElementById('run-fill').style.width = runEnergy + '%';
    }

    function addInventoryItem() {
        if(inventory < 4) {
            const slot = document.getElementById('slot-' + inventory);
            const item = document.createElement('div');
            item.className = 'inv-item log-item';
            slot.appendChild(item);
            inventory++;
        }
    }

    function spawnXP(x, y, z) {
        const div = document.createElement('div');
        div.className = 'xp-drop';
        div.textContent = "+25 XP";
        document.body.appendChild(div);

        // Project 3D pos to 2D screen
        const v = new THREE.Vector3(x, y+2, z);
        v.project(camera);
        const sx = (v.x * .5 + .5) * window.innerWidth;
        const sy = (-(v.y * .5) + .5) * window.innerHeight;
        div.style.left = sx + 'px';
        div.style.top = sy + 'px';

        setTimeout(() => div.remove(), 1400);
    }

    // --- MINIMAP LOGIC ---
    const ctx = document.getElementById('minimap-canvas').getContext('2d');
    function drawMinimap() {
        ctx.fillStyle = '#222'; ctx.fillRect(0,0,120,120);
        
        // Draw Player (Center)
        ctx.fillStyle = '#fff'; 
        ctx.beginPath(); ctx.arc(60,60,3,0,Math.PI*2); ctx.fill();

        // Helper to map world pos to minimap
        const mapScale = 2; // Zoom level
        function drawDot(obj, color, size) {
            const dx = obj.position.x - playerGroup.position.x;
            const dz = obj.position.z - playerGroup.position.z;
            const mx = 60 + dx * mapScale;
            const mz = 60 + dz * mapScale; // Z is Y on 2D map usually
            
            // Clamp to circle
            const dist = Math.sqrt((mx-60)**2 + (mz-60)**2);
            if(dist < 58) {
                ctx.fillStyle = color;
                ctx.beginPath(); ctx.arc(mx,mz,size,0,Math.PI*2); ctx.fill();
            }
        }

        // Draw Dragon
        drawDot(dragonGroup, '#d63031', 4);
        // Draw Fox
        drawDot(foxGroup, '#e67e22', 2);
        // Draw Trees
        trees.forEach(t => drawDot(t, '#2ecc71', 1.5));
    }


    // --- CONTROLS ---
    const joyZone = document.getElementById('joystick-zone');
    const joyNip = document.getElementById('joystick-nipple');
    const moveVector = new THREE.Vector2(0,0);
    let joyId = null;

    joyZone.addEventListener('touchstart', e => {
        e.preventDefault(); if(joyId!==null) return;
        joyId=e.changedTouches[0].identifier; handleJoy(e.changedTouches[0]);
    });
    joyZone.addEventListener('touchmove', e => {
        e.preventDefault(); for(let t of e.changedTouches) if(t.identifier===joyId) handleJoy(t);
    });
    const endJoy = () => { joyId=null; moveVector.set(0,0); joyNip.style.transform=`translate(-50%,-50%)`; };
    joyZone.addEventListener('touchend', endJoy); joyZone.addEventListener('touchcancel', endJoy);

    function handleJoy(touch) {
        const r = joyZone.getBoundingClientRect();
        const cx = r.left+r.width/2, cy = r.top+r.height/2;
        let dx = touch.clientX - cx, dy = touch.clientY - cy;
        const d = Math.min(Math.sqrt(dx*dx+dy*dy), 50);
        const a = Math.atan2(dy, dx);
        dx = Math.cos(a)*d; dy = Math.sin(a)*d;
        joyNip.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        moveVector.x = dx/50; moveVector.y = dy/50;
    }

    let jumpVel = 0;
    document.getElementById('btn-jump').addEventListener('pointerdown', e=>{ e.preventDefault(); if(playerGroup.position.y<=0) jumpVel=0.4; });
    document.getElementById('btn-axe').addEventListener('pointerdown', e=>{ e.preventDefault(); spawnAxe(); });

    function spawnAxe() {
        const g = new THREE.Group();
        const h = new THREE.Mesh(new THREE.BoxGeometry(0.1,1.5,0.1), new THREE.MeshStandardMaterial({color:0x654321}));
        const b = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.6,0.1), new THREE.MeshStandardMaterial({color:0xaaa, emissive:0x0ff, emissiveIntensity:0.5}));
        b.position.y=0.5; g.add(h); g.add(b);
        g.position.copy(playerGroup.position); g.position.y+=2.5;
        const dir = new THREE.Vector3(0,0,1).applyQuaternion(playerGroup.quaternion);
        projectiles.push({mesh:g, dir:dir, life:80});
        scene.add(g);
    }

    // --- ANIMATION LOOP ---
    const clock = new THREE.Clock();
    let foxTimer = 0; let foxState="wander"; let foxTarget=new THREE.Vector3(5,0,5);
    let dragonTimer = 0; let dragonTarget=new THREE.Vector3(-20,0,-20);

    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        const time = clock.getElapsedTime();

        // 1. PLAYER MOVE
        if(moveVector.lengthSq() > 0.01) {
            const camDir = new THREE.Vector3(); camera.getWorldDirection(camDir); camDir.y=0; camDir.normalize();
            const camRight = new THREE.Vector3().crossVectors(camDir, new THREE.Object3D().up).normalize();
            
            // Invert Y: Screen Up (Neg) -> World Forward (Pos)
            const move = new THREE.Vector3().addScaledVector(camDir, -moveVector.y).addScaledVector(camRight, moveVector.x);
            
            if(move.lengthSq()>0) {
                move.normalize();
                const speed = 12 * dt;
                playerGroup.position.add(move.multiplyScalar(speed));
                playerGroup.rotation.y = Math.atan2(move.x, move.z);
                
                // Run Energy
                runEnergy = Math.max(0, runEnergy - 5*dt);
                
                // Anim
                lLeg.rotation.x = Math.sin(time*15)*0.8; rLeg.rotation.x = Math.sin(time*15+Math.PI)*0.8;
                lArm.rotation.x = Math.sin(time*15+Math.PI)*0.8; rArm.rotation.x = Math.sin(time*15)*0.8;
            }
        } else {
            // Idle / Regen
            runEnergy = Math.min(100, runEnergy + 2*dt);
            lLeg.rotation.x=rLeg.rotation.x=lArm.rotation.x=rArm.rotation.x=0;
        }
        updateHUD();

        // Jump
        if(jumpVel>0 || playerGroup.position.y>0) {
            playerGroup.position.y+=jumpVel; jumpVel-=0.02;
            if(playerGroup.position.y<0){ playerGroup.position.y=0; jumpVel=0; }
        }

        // 2. PROJECTILES & TREE LOGIC
        for(let i=projectiles.length-1; i>=0; i--) {
            const p = projectiles[i];
            p.mesh.position.add(p.dir.clone().multiplyScalar(0.7));
            p.mesh.rotation.z -= 0.6;
            p.life--;
            let hit=false;
            for(let j=trees.length-1; j>=0; j--) {
                const t = trees[j];
                if(t.userData.hp>0 && p.mesh.position.distanceTo(t.position)<3) {
                    t.userData.hp=0; hit=true;
                    // XP Drop
                    spawnXP(t.position.x, t.position.y, t.position.z);
                    // Loot
                    addInventoryItem();
                    // Fall
                    let fall=0;
                    const anim=setInterval(()=>{
                        t.rotation.x+=0.05; t.position.y-=0.1;
                        if(++fall>20) { clearInterval(anim); scene.remove(t); }
                    }, 20);
                }
            }
            if(p.life<=0 || hit) { scene.remove(p.mesh); projectiles.splice(i,1); }
        }

        // 3. FOX AI (Wander & Dig)
        foxTimer-=dt;
        if(foxState==="wander") {
            foxGroup.rotation.x=0;
            if(foxTimer<0) {
                foxTarget.set((Math.random()-0.5)*80, 0, (Math.random()-0.5)*80);
                foxTimer=3+Math.random()*3;
                if(Math.random()>0.7) foxState="dig";
            }
            const d = new THREE.Vector3().subVectors(foxTarget, foxGroup.position);
            if(d.length()>1) {
                d.normalize(); foxGroup.position.add(d.multiplyScalar(6*dt));
                foxGroup.lookAt(foxTarget);
                fLegs.forEach((l,k) => l.rotation.x = Math.sin(time*20 + (k%2)*Math.PI)*0.5);
            }
        } else {
            // Dig
            foxGroup.rotation.x=0.4;
            fLegs[0].rotation.x = Math.sin(time*40)*1.0; fLegs[1].rotation.x = Math.cos(time*40)*1.0;
            if(Math.random()>0.85) {
                // Dirt particle
                const p=new THREE.Mesh(new THREE.BoxGeometry(0.3,0.3,0.3), new THREE.MeshBasicMaterial({color:0x3e2723}));
                p.position.copy(foxGroup.position).add(new THREE.Vector3(0,0,1.5).applyQuaternion(foxGroup.quaternion));
                scene.add(p); particles.push({mesh:p, vel:new THREE.Vector3((Math.random()-.5), 1, (Math.random()-.5)).multiplyScalar(0.2), life:30});
            }
            if(foxTimer<=0) { foxState="wander"; foxTimer=2; }
        }

        // 4. DRAGON AI (Patrol)
        dragonTimer-=dt;
        if(dragonTimer<0) {
            dragonTarget.set((Math.random()-0.5)*150, 0, (Math.random()-0.5)*150);
            dragonTimer=5+Math.random()*5;
        }
        const dragDir = new THREE.Vector3().subVectors(dragonTarget, dragonGroup.position);
        if(dragDir.length()>1) {
            dragDir.normalize(); dragonGroup.position.add(dragDir.multiplyScalar(5*dt));
            dragonGroup.lookAt(dragonTarget);
            dWingL.rotation.z = Math.sin(time*5)*0.5;
            dWingR.rotation.z = -Math.sin(time*5)*0.5;
        }

        // Particles
        for(let i=particles.length-1; i>=0; i--) {
            particles[i].mesh.position.add(particles[i].vel);
            particles[i].vel.y-=0.01; particles[i].life--;
            if(particles[i].life<=0){ scene.remove(particles[i].mesh); particles.splice(i,1); }
        }

        // Camera
        controls.target.copy(playerGroup.position);
        controls.target.y = 1;
        controls.update();
        
        // Minimap
        drawMinimap();

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>

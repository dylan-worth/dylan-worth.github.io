<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RS Style: Forest Start</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; touch-action: none; }
        
        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffff00; /* RS Gold Text */
            text-shadow: 1px 1px #000;
            pointer-events: none;
            z-index: 10;
        }
        #health-bar {
            width: 150px;
            height: 15px;
            background: #500;
            border: 2px solid #333;
            margin-top: 5px;
        }
        #health-fill { width: 100%; height: 100%; background: #0f0; }

        /* Mobile Joystick UI */
        #joystick-zone {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            z-index: 20;
            touch-action: none; /* Important for preventing scrolling */
        }
        #joystick-nipple {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Let touches pass through to the zone */
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <h3 style="margin: 0;">Lumby Forest</h3>
    <div id="health-bar"><div id="health-fill"></div></div>
</div>

<div id="joystick-zone">
    <div id="joystick-nipple"></div>
</div>


<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); // Sky Blue
    scene.fog = new THREE.Fog(0x87CEEB, 30, 100); // Light distant haze

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 12, 15); // Higher angle for mobile view

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // Controls (Orbit camera)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.maxPolarAngle = Math.PI / 2.1;
    controls.minDistance = 5;
    controls.maxDistance = 30;

    // --- 2. BEAUTIFUL FOREST ENVIRONMENT ---
    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);

    const sunLight = new THREE.DirectionalLight(0xfff0dd, 1.5); // Warm sun
    sunLight.position.set(50, 100, -50);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 2048;
    sunLight.shadow.mapSize.height = 2048;
    sunLight.shadow.camera.near = 0.5;
    sunLight.shadow.camera.far = 500;
    sunLight.shadow.camera.left = -100; sunLight.shadow.camera.right = 100;
    sunLight.shadow.camera.top = 100; sunLight.shadow.camera.bottom = -100;
    scene.add(sunLight);

    // Ground (Lush Grass)
    const groundGeo = new THREE.PlaneGeometry(200, 200);
    const groundMat = new THREE.MeshStandardMaterial({ 
        color: 0x2d5e1e, // Forest Green
        roughness: 0.8,
        metalness: 0.1
    }); 
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Forest Scenery (Procedural low-poly trees)
    function createForest() {
        const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 2, 6);
        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4d3319 }); // Brown
        const leavesGeo = new THREE.ConeGeometry(2.5, 5, 7);
        const leavesMat = new THREE.MeshStandardMaterial({ color: 0x1e6b22 }); // Dark Green

        for (let i = 0; i < 60; i++) {
            const treeGroup = new THREE.Group();
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 4;
            leaves.castShadow = true;
            treeGroup.add(leaves);

            let x = (Math.random() - 0.5) * 180;
            let z = (Math.random() - 0.5) * 180;
            // Keep center relatively clear
            if(Math.abs(x) < 10 && Math.abs(z) < 10) { x+=20; z+=20; }

            treeGroup.position.set(x, 0, z);
            treeGroup.scale.setScalar(Math.random() * 0.5 + 0.8);
            scene.add(treeGroup);
        }
    }
    createForest();


    // --- 3. CHARACTER (Not a box anymore!) ---
    // We build a simple low-poly humanoid entirely in code so no external files needed.
    function createCharacter() {
        const charGroup = new THREE.Group();

        // Head
        const headGeo = new THREE.SphereGeometry(0.4, 8, 8);
        const skinMat = new THREE.MeshStandardMaterial({ color: 0xf5cca8 }); // Peach
        const head = new THREE.Mesh(headGeo, skinMat);
        head.position.y = 2.6;
        charGroup.add(head);

        // Body (Torso / Armor)
        const bodyGeo = new THREE.CylinderGeometry(0.6, 0.5, 1.2, 6);
        const armorMat = new THREE.MeshStandardMaterial({ color: 0x336699, metalness: 0.4 }); // Blue armor
        const body = new THREE.Mesh(bodyGeo, armorMat);
        body.position.y = 1.6;
        body.castShadow = true;
        charGroup.add(body);

        // Legs (Simple block for now to represent legs)
        const legsGeo = new THREE.BoxGeometry(0.7, 1, 0.5);
        const legsMat = new THREE.MeshStandardMaterial({ color: 0x222222 }); // Dark grey pants
        const legs = new THREE.Mesh(legsGeo, legsMat);
        legs.position.y = 0.5;
        legs.castShadow = true;
        charGroup.add(legs);

        return charGroup;
    }

    const player = createCharacter();
    scene.add(player);


    // --- 4. MOBILE JOYSTICK LOGIC ---
    const joystickZone = document.getElementById('joystick-zone');
    const joystickNipple = document.getElementById('joystick-nipple');
    const moveVector = new THREE.Vector2(0, 0); // Stores X and Y movement intention (-1 to 1)
    let joystickTouchId = null;
    const maxRadius = 50; // Max distance nipple moves from center

    joystickZone.addEventListener('touchstart', function(e) {
        e.preventDefault();
        if (joystickTouchId !== null) return; // Already touching
        const touch = e.changedTouches[0];
        joystickTouchId = touch.identifier;
        handleJoystickMove(touch.clientX, touch.clientY);
    }, { passive: false });

    joystickZone.addEventListener('touchmove', function(e) {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === joystickTouchId) {
                handleJoystickMove(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                break;
            }
        }
    }, { passive: false });

    ['touchend', 'touchcancel'].forEach(evt => {
        joystickZone.addEventListener(evt, function(e) {
             e.preventDefault();
             for (let i = 0; i < e.changedTouches.length; i++) {
                if (e.changedTouches[i].identifier === joystickTouchId) {
                    resetJoystick();
                    break;
                }
            }
        });
    });

    function handleJoystickMove(touchX, touchY) {
        const rect = joystickZone.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        let deltaX = touchX - centerX;
        let deltaY = touchY - centerY;
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

        // Clamp distance to maxRadius
        if (distance > maxRadius) {
            const ratio = maxRadius / distance;
            deltaX *= ratio;
            deltaY *= ratio;
        }

        // Move UI element relative to center
        joystickNipple.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

        // Normalize vector for movement (-1 to 1 range)
        moveVector.x = deltaX / maxRadius;
        moveVector.y = -deltaY / maxRadius; // Invert Y because screen Y is opposite 3D world Z
    }

    function resetJoystick() {
        joystickTouchId = null;
        moveVector.set(0, 0);
        joystickNipple.style.transform = `translate(-50%, -50%)`;
    }


    // --- 5. GAME LOOP ---
    let playerSpeed = 0.15;
    let playerHealth = 100;

    function updatePlayerInteraction() {
        if(playerHealth <= 0) return;

        // Movement based on joystick vector
        if (moveVector.lengthSq() > 0.01) {
             // Calculate movement direction relative to camera angle
             const angleYCameraDirection = Math.atan2(
                 (camera.position.x - player.position.x),
                 (camera.position.z - player.position.z)
             );
             const diagonalOffset = Math.atan2(moveVector.x, moveVector.y);
             
             const moveAngle = angleYCameraDirection + diagonalOffset;
             
             player.position.x -= Math.sin(moveAngle) * playerSpeed * moveVector.length();
             player.position.z -= Math.cos(moveAngle) * playerSpeed * moveVector.length();

             // Rotate character to face movement direction
             player.rotation.y = moveAngle + Math.PI;
        }

        // Simple Camera Follow
        camera.position.x += (player.position.x - camera.position.x) * 0.08;
        camera.position.z += (player.position.z + 15 - camera.position.z) * 0.08;
        controls.target.copy(player.position);
        controls.target.y = 1; // Look at body height
        controls.update();
    }

    function animate() {
        requestAnimationFrame(animate);
        updatePlayerInteraction();
        renderer.render(scene, camera);
    }

    // Handle Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>

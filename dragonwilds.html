<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>RS Style: Magic Axe Update</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: 'Courier New', Courier, monospace; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffff00;
            text-shadow: 1px 1px #000;
            pointer-events: none;
            z-index: 10;
        }

        /* Controls Container */
        #controls-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            height: 150px;
            pointer-events: none; /* Let clicks pass through empty space */
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        /* Joystick */
        #joystick-zone {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.4);
            pointer-events: auto;
            position: relative;
        }
        #joystick-nipple {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        /* Action Buttons */
        .btn-group {
            display: flex;
            gap: 15px;
            pointer-events: auto;
            padding-bottom: 10px;
        }
        .action-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid #ccc;
            background: rgba(0,0,0,0.5);
            color: white;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            active: scale(0.9);
            cursor: pointer;
        }
        #btn-axe { background: linear-gradient(135deg, #4b0082, #800080); border-color: #d8bfd8; }
        #btn-jump { background: linear-gradient(135deg, #228b22, #32cd32); border-color: #90ee90; }

    </style>
</head>
<body>

<div id="ui-layer">
    <h3 style="margin: 0;">Magic Woods</h3>
    <div>Tap "Throw Axe" to cut trees</div>
</div>

<div id="controls-container">
    <div id="joystick-zone">
        <div id="joystick-nipple"></div>
    </div>
    
    <div class="btn-group">
        <div id="btn-axe" class="action-btn">THROW<br>AXE</div>
        <div id="btn-jump" class="action-btn">JUMP</div>
    </div>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // --- 1. SETUP ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB); 
    scene.fog = new THREE.Fog(0x87CEEB, 20, 80);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 15, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enablePan = false;
    controls.enableZoom = false; // Lock zoom for mobile feel
    controls.maxPolarAngle = Math.PI / 2.2;

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const sunLight = new THREE.DirectionalLight(0xfff0dd, 1.2);
    sunLight.position.set(30, 50, 20);
    sunLight.castShadow = true;
    sunLight.shadow.mapSize.width = 1024;
    sunLight.shadow.mapSize.height = 1024;
    scene.add(sunLight);

    // Ground
    const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(200, 200),
        new THREE.MeshStandardMaterial({ color: 0x3a7e2c, roughness: 1 })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // --- 2. GAME OBJECTS ---

    // Array to store tree objects for collision detection
    const trees = [];
    const projectiles = [];

    // Create Trees
    const treeGeo = new THREE.ConeGeometry(2, 6, 8);
    const trunkGeo = new THREE.CylinderGeometry(0.5, 0.7, 2, 6);
    const treeMat = new THREE.MeshStandardMaterial({ color: 0x1e6b22 });
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });

    function spawnTree(x, z) {
        const group = new THREE.Group();
        
        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
        trunk.position.y = 1;
        trunk.castShadow = true;
        group.add(trunk);

        const leaves = new THREE.Mesh(treeGeo, treeMat);
        leaves.position.y = 4;
        leaves.castShadow = true;
        group.add(leaves);

        group.position.set(x, 0, z);
        
        // Add random scale variety
        const s = 0.8 + Math.random() * 0.5;
        group.scale.set(s,s,s);
        
        // Tag it for game logic
        group.userData = { type: 'tree', hp: 1 };
        
        scene.add(group);
        trees.push(group);
    }

    // Populate Forest
    for(let i=0; i<40; i++) {
        const x = (Math.random() - 0.5) * 150;
        const z = (Math.random() - 0.5) * 150;
        if (Math.abs(x) > 5 || Math.abs(z) > 5) spawnTree(x, z);
    }

    // --- 3. ANIMATED CHARACTER ---
    const playerGroup = new THREE.Group();
    scene.add(playerGroup);

    // Body Parts (Saved to variables so we can animate them)
    const charBody = new THREE.Group();
    
    // Torso
    const torsoMesh = new THREE.Mesh(
        new THREE.BoxGeometry(1, 1.5, 0.6),
        new THREE.MeshStandardMaterial({ color: 0x336699 }) // Blue Platebody
    );
    torsoMesh.position.y = 2.25;
    torsoMesh.castShadow = true;
    charBody.add(torsoMesh);

    // Head
    const headMesh = new THREE.Mesh(
        new THREE.BoxGeometry(0.6, 0.6, 0.6),
        new THREE.MeshStandardMaterial({ color: 0xf5cca8 })
    );
    headMesh.position.y = 3.3;
    charBody.add(headMesh);

    // Pivot points for limbs are important for rotation
    function createLimb(w, h, d, color, x, y, z) {
        const pivot = new THREE.Group();
        pivot.position.set(x, y, z);
        const mesh = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            new THREE.MeshStandardMaterial({ color: color })
        );
        mesh.position.y = -h / 2; // Offset geometry so pivot is at top
        mesh.castShadow = true;
        pivot.add(mesh);
        return pivot;
    }

    const leftArm = createLimb(0.3, 1.2, 0.3, 0x336699, -0.7, 2.8, 0);
    const rightArm = createLimb(0.3, 1.2, 0.3, 0x336699, 0.7, 2.8, 0);
    const leftLeg = createLimb(0.35, 1.5, 0.4, 0x555555, -0.3, 1.5, 0);
    const rightLeg = createLimb(0.35, 1.5, 0.4, 0x555555, 0.3, 1.5, 0);

    charBody.add(leftArm);
    charBody.add(rightArm);
    charBody.add(leftLeg);
    charBody.add(rightLeg);
    
    playerGroup.add(charBody);


    // --- 4. GAME MECHANICS: AXE & JUMP ---
    
    // Throw Axe Logic
    document.getElementById('btn-axe').addEventListener('pointerdown', (e) => {
        e.preventDefault(); 
        spawnAxe();
    });
    
    // Jump Logic
    let verticalVelocity = 0;
    let isJumping = false;
    document.getElementById('btn-jump').addEventListener('pointerdown', (e) => {
        e.preventDefault();
        if (!isJumping) {
            verticalVelocity = 0.4;
            isJumping = true;
        }
    });

    function spawnAxe() {
        const axeGroup = new THREE.Group();
        
        // Axe Handle
        const handle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.5, 0.1), new THREE.MeshStandardMaterial({color: 0x654321}));
        axeGroup.add(handle);
        
        // Axe Blade
        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.1), new THREE.MeshStandardMaterial({color: 0xaaaaaa, metalness: 0.8, emissive: 0x00ffff, emissiveIntensity: 0.5}));
        blade.position.set(0, 0.5, 0);
        axeGroup.add(blade);

        // Start position: slightly in front of player
        axeGroup.position.copy(playerGroup.position);
        axeGroup.position.y += 2.5; 
        
        // Direction: Player's current forward direction
        const direction = new THREE.Vector3(0, 0, 1);
        direction.applyQuaternion(playerGroup.quaternion);
        
        // Magic Trail (PointLight)
        const light = new THREE.PointLight(0x00ffff, 1, 5);
        axeGroup.add(light);

        scene.add(axeGroup);
        
        // Add to projectiles array
        projectiles.push({ mesh: axeGroup, dir: direction, life: 100 });
    }

    // --- 5. JOYSTICK LOGIC ---
    const joystickZone = document.getElementById('joystick-zone');
    const joystickNipple = document.getElementById('joystick-nipple');
    let moveVector = new THREE.Vector2(0, 0);
    let joystickTouchId = null;

    joystickZone.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (joystickTouchId !== null) return;
        const touch = e.changedTouches[0];
        joystickTouchId = touch.identifier;
        updateJoystick(touch.clientX, touch.clientY);
    });

    joystickZone.addEventListener('touchmove', (e) => {
        e.preventDefault();
        for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === joystickTouchId) {
                updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
            }
        }
    });

    const resetJoy = () => { joystickTouchId = null; moveVector.set(0,0); joystickNipple.style.transform = `translate(-50%,-50%)`; };
    joystickZone.addEventListener('touchend', resetJoy);
    joystickZone.addEventListener('touchcancel', resetJoy);

    function updateJoystick(x, y) {
        const rect = joystickZone.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        let dx = x - centerX;
        let dy = y - centerY;
        const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 60); // Cap radius
        const angle = Math.atan2(dy, dx);
        
        dx = Math.cos(angle) * dist;
        dy = Math.sin(angle) * dist;

        joystickNipple.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        
        // Map to -1 to 1. In screen space, -Y is Up. 
        moveVector.x = dx / 60; 
        moveVector.y = dy / 60; 
    }

    // --- 6. GAME LOOP ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        const time = clock.getElapsedTime();

        // 1. Player Movement & Animation
        if (moveVector.lengthSq() > 0.01) {
            // Calculate direction relative to camera
            // Camera looks at player. We want "Up" on joystick to move AWAY from camera.
            
            // Get camera Y rotation
            const camDir = new THREE.Vector3();
            camera.getWorldDirection(camDir);
            const camAngle = Math.atan2(camDir.x, camDir.z); // Angle in radians

            // Joystick Angle (Inverted Y because screen Y+ is Down)
            // Screen X+ is Right, Screen Y+ is Down. 
            // 3D X+ is Right, 3D Z+ is Back (Toward Camera).
            const joyAngle = Math.atan2(moveVector.x, moveVector.y);
            
            // Combine angles.
            const moveDirection = joyAngle + camAngle; 

            // Move Player
            const speed = 10 * delta;
            playerGroup.position.x += Math.sin(moveDirection) * speed;
            playerGroup.position.z += Math.cos(moveDirection) * speed;
            
            // Rotate Player to face movement
            playerGroup.rotation.y = moveDirection;

            // Run Animation (Sine wave on limbs)
            const freq = 15;
            leftLeg.rotation.x = Math.sin(time * freq) * 0.8;
            rightLeg.rotation.x = Math.sin(time * freq + Math.PI) * 0.8;
            leftArm.rotation.x = Math.sin(time * freq + Math.PI) * 0.8;
            rightArm.rotation.x = Math.sin(time * freq) * 0.8;

        } else {
            // Idle Pose
            leftLeg.rotation.x = 0;
            rightLeg.rotation.x = 0;
            leftArm.rotation.x = 0;
            rightArm.rotation.x = 0;
        }

        // 2. Jump Physics
        if (isJumping || playerGroup.position.y > 0) {
            playerGroup.position.y += verticalVelocity;
            verticalVelocity -= 0.02; // Gravity

            if (playerGroup.position.y <= 0) {
                playerGroup.position.y = 0;
                isJumping = false;
                verticalVelocity = 0;
            }
        }

        // 3. Projectiles & Tree Cutting
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.mesh.position.add(p.dir.clone().multiplyScalar(0.5)); // Speed
            p.mesh.rotation.z -= 0.5; // Spin animation
            p.life--;

            let hit = false;
            // Collision Check
            for (let j = trees.length - 1; j >= 0; j--) {
                if (trees[j].userData.hp > 0 && p.mesh.position.distanceTo(trees[j].position) < 3) {
                    // Tree Hit!
                    trees[j].userData.hp = 0;
                    
                    // Fall animation (using GSAP style manual tween)
                    const tree = trees[j];
                    const fallInterval = setInterval(() => {
                         tree.rotation.x += 0.05;
                         tree.position.y -= 0.1;
                         tree.scale.multiplyScalar(0.95);
                         if(tree.scale.x < 0.1) {
                             clearInterval(fallInterval);
                             scene.remove(tree);
                         }
                    }, 16);

                    hit = true;
                    break;
                }
            }

            if (p.life <= 0 || hit) {
                scene.remove(p.mesh);
                projectiles.splice(i, 1);
            }
        }

        // 4. Camera Follow
        const targetX = playerGroup.position.x;
        const targetZ = playerGroup.position.z + 15; // Camera sits behind
        camera.position.x += (targetX - camera.position.x) * 0.1;
        camera.position.z += (targetZ - camera.position.z) * 0.1;
        camera.lookAt(playerGroup.position.x, playerGroup.position.y + 2, playerGroup.position.z);

        renderer.render(scene, camera);
    }

    // Resize
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>

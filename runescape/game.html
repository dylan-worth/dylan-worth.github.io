<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Open881 - 3D Client</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Trebuchet MS', sans-serif; background: #000; }
        
        /* --- UI OVERLAYS (RS3 Style) --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* Top Bar */
        .top-bar {
            background: rgba(8, 30, 43, 0.9); border-bottom: 2px solid #3c4b57;
            padding: 10px; color: #ffd700; font-weight: bold; pointer-events: auto;
            display: flex; gap: 15px;
        }
        .tele-btn {
            background: #1a2a36; border: 1px solid #00ccff; color: #00ccff;
            padding: 5px 15px; cursor: pointer; text-transform: uppercase; font-size: 0.8rem;
        }
        .tele-btn:hover { background: #00ccff; color: #000; box-shadow: 0 0 10px #00ccff; }

        /* Action Bar */
        .action-bar {
            align-self: center; margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.6); border: 1px solid #3c4b57;
            display: flex; gap: 5px; padding: 5px; pointer-events: auto;
        }
        .slot {
            width: 40px; height: 40px; background: #2b3945; border: 1px solid #5a7b8f;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            position: relative; font-size: 20px;
        }
        .slot:hover { border-color: #ffd700; }
        .slot span { position: absolute; bottom: 2px; right: 2px; font-size: 8px; color: #fff; }

        /* Tooltip / Context */
        #context-menu {
            position: absolute; top: 50px; left: 50%; transform: translateX(-50%);
            color: #00ff00; text-shadow: 1px 1px 0 #000; font-weight: bold; pointer-events: none;
        }

        /* Health Bar */
        #hp-bar {
            position: absolute; top: 10px; right: 10px; width: 200px; height: 20px;
            background: #330000; border: 1px solid #5a7b8f;
        }
        #hp-fill { width: 100%; height: 100%; background: #00ff00; transition: width 0.2s; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <div class="top-bar">
            <span>Open881 Client</span>
            <button class="tele-btn" onclick="window.game.teleport('home')">üè† Menaphos</button>
            <button class="tele-btn" onclick="window.game.teleport('forest')">üå≤ Lumbridge</button>
            <button class="tele-btn" onclick="window.game.teleport('ice')">‚ùÑÔ∏è Senntisten</button>
        </div>
        
        <div id="context-menu">Welcome to Gielinor</div>

        <div id="hp-bar"><div id="hp-fill"></div></div>

        <div class="action-bar">
            <div class="slot" onclick="window.game.castSpell('alch')">üí∞<span>Alch</span></div>
            <div class="slot" onclick="window.game.castSpell('barrage')">‚ùÑÔ∏è<span>Barrage</span></div>
            <div class="slot" onclick="window.game.castSpell('veng')">üíÄ<span>Veng</span></div>
            <div class="slot" onclick="window.game.castSpell('heal')">üåô<span>Heal</span></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        class Game {
            constructor() {
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87CEEB); // Sky blue
                this.scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 15, 15);
                this.camera.lookAt(0, 0, 0);

                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.body.appendChild(this.renderer.domElement);

                // Inputs
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                // Game State
                this.player = null;
                this.targetPos = new THREE.Vector3();
                this.isMoving = false;
                this.mobs = [];
                this.farms = [];
                this.particles = [];

                this.init();
                this.animate();
            }

            init() {
                // Lights
                const ambient = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambient);
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(50, 100, 50);
                dirLight.castShadow = true;
                this.scene.add(dirLight);

                // --- WORLD GENERATION ---
                this.createTerrain();
                this.player = this.createHumanoid(0x8B4513, 0xCCCCCC); // Brown skin, Grey Armor
                this.scene.add(this.player);

                // Mobs (Not Cylinders!)
                this.createMob('Goblin', -10, -10, 0x00ff00);
                this.createMob('Demon', 10, -15, 0xff0000);
                
                // Farming Plots
                this.createFarmPlot(-5, 5);
                this.createFarmPlot(5, 5);

                // Event Listeners
                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('mousedown', (e) => this.onClick(e));
                
                // Expose to window for UI buttons
                window.game = this; 
            }

            // --- ASSET GENERATION (Procedural Models) ---
            createHumanoid(skinColor, armorColor) {
                const group = new THREE.Group();

                // Head
                const headGeo = new THREE.BoxGeometry(0.8, 0.9, 0.8);
                const headMat = new THREE.MeshStandardMaterial({ color: skinColor });
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 3.5;
                head.castShadow = true;
                group.add(head);

                // Torso
                const bodyGeo = new THREE.BoxGeometry(1.2, 1.5, 0.6);
                const bodyMat = new THREE.MeshStandardMaterial({ color: armorColor });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 2.2;
                body.castShadow = true;
                group.add(body);

                // Arms
                const armGeo = new THREE.BoxGeometry(0.35, 1.2, 0.35);
                const armL = new THREE.Mesh(armGeo, headMat);
                armL.position.set(-0.8, 2.2, 0);
                group.add(armL);
                
                const armR = new THREE.Mesh(armGeo, headMat);
                armR.position.set(0.8, 2.2, 0);
                group.add(armR);

                // Legs
                const legGeo = new THREE.BoxGeometry(0.4, 1.5, 0.4);
                const legMat = new THREE.MeshStandardMaterial({ color: 0x333333 }); // Pants
                const legL = new THREE.Mesh(legGeo, legMat);
                legL.position.set(-0.3, 0.75, 0);
                group.add(legL);

                const legR = new THREE.Mesh(legGeo, legMat);
                legR.position.set(0.3, 0.75, 0);
                group.add(legR);

                return group;
            }

            createMob(type, x, z, color) {
                const mob = this.createHumanoid(color, 0x222222);
                mob.position.set(x, 0, z);
                
                // Scaling for monster variety
                if(type === 'Demon') mob.scale.set(1.5, 1.5, 1.5); // Big
                if(type === 'Goblin') mob.scale.set(0.7, 0.7, 0.7); // Small

                mob.userData = { type: type, hp: 100, maxHp: 100 };
                this.scene.add(mob);
                this.mobs.push(mob);
            }

            createTerrain() {
                // Menaphos (Sand)
                const sandGeo = new THREE.PlaneGeometry(100, 100);
                const sandMat = new THREE.MeshStandardMaterial({ color: 0xe6c288 });
                const sand = new THREE.Mesh(sandGeo, sandMat);
                sand.rotation.x = -Math.PI / 2;
                sand.receiveShadow = true;
                this.scene.add(sand);

                // Lumbridge (Grass)
                const grassGeo = new THREE.PlaneGeometry(50, 50);
                const grassMat = new THREE.MeshStandardMaterial({ color: 0x2d5a27 });
                const grass = new THREE.Mesh(grassGeo, grassMat);
                grass.rotation.x = -Math.PI / 2;
                grass.position.set(50, 0.01, 50); // Offset
                this.scene.add(grass);

                // Ice (White)
                const iceGeo = new THREE.PlaneGeometry(50, 50);
                const iceMat = new THREE.MeshStandardMaterial({ color: 0xdfffff, roughness: 0.1 });
                const ice = new THREE.Mesh(iceGeo, iceMat);
                ice.rotation.x = -Math.PI / 2;
                ice.position.set(-50, 0.01, 50);
                this.scene.add(ice);
            }

            createFarmPlot(x, z) {
                const plotGeo = new THREE.PlaneGeometry(3, 3);
                const plotMat = new THREE.MeshStandardMaterial({ color: 0x3d2817 }); // Soil
                const plot = new THREE.Mesh(plotGeo, plotMat);
                plot.rotation.x = -Math.PI / 2;
                plot.position.set(x, 0.02, z);
                
                plot.userData = { isFarm: true, stage: 0, mesh: plot };
                this.scene.add(plot);
                this.farms.push(plot);
            }

            // --- GAMEPLAY MECHANICS ---

            teleport(location) {
                this.createTeleportEffect(this.player.position);
                
                setTimeout(() => {
                    if(location === 'home') this.player.position.set(0, 0, 0);
                    if(location === 'forest') this.player.position.set(50, 0, 50);
                    if(location === 'ice') this.player.position.set(-50, 0, 50);
                    
                    this.targetPos.copy(this.player.position); // Stop moving
                    this.updateContext(`Teleported to ${location}`);
                }, 1000);
            }

            castSpell(type) {
                const pPos = this.player.position;
                if(type === 'alch') {
                    this.spawnParticles(pPos, 0xffd700, 20); // Gold
                    this.updateContext("Cast High Level Alchemy");
                }
                if(type === 'barrage') {
                    this.spawnParticles(pPos, 0x00ffff, 50); // Ice Square
                    this.updateContext("Cast Ice Barrage");
                }
                if(type === 'veng') {
                    this.spawnParticles(pPos, 0xff0000, 10); // Red Skull vibe
                    this.updateContext("Taste Vengeance!");
                }
                if(type === 'heal') {
                    this.spawnParticles(pPos, 0xffffff, 30); // White/Pink
                    this.updateContext("Cast Heal Other");
                }
            }

            growFarm(plot) {
                plot.userData.stage++;
                if(plot.userData.stage > 3) plot.userData.stage = 0; // Reset

                const stage = plot.userData.stage;
                if(stage === 0) {
                    plot.material.color.setHex(0x3d2817); // Dirt
                    this.updateContext("Patched cleared.");
                } else if (stage === 1) {
                    plot.material.color.setHex(0x00aa00); // Seeds
                    this.updateContext("Seeds planted.");
                } else if (stage === 2) {
                    // Add a simple plant mesh if you want, changing color for now
                    plot.material.color.setHex(0x00ff00); // Grown
                    this.updateContext("Crops growing...");
                } else {
                    plot.material.color.setHex(0xffaa00); // Harvest
                    this.updateContext("Harvested crops! +XP");
                }
            }

            // --- INTERACTION ---

            onClick(event) {
                if(event.target.closest('.tele-btn') || event.target.closest('.slot')) return;

                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.scene.children, true);

                if (intersects.length > 0) {
                    const hit = intersects[0];
                    const obj = hit.object;

                    // Check for Mob
                    const parent = obj.parent;
                    if(parent && parent.userData.type) {
                        this.spawnParticles(parent.position, 0xff0000, 5); // Blood splat
                        this.updateContext(`Attacking ${parent.userData.type}`);
                        return;
                    }

                    // Check for Farm
                    if(obj.userData.isFarm) {
                        this.growFarm(obj);
                        return;
                    }

                    // Move Player
                    this.targetPos.set(hit.point.x, 0, hit.point.z);
                    this.isMoving = true;
                    this.createMarker(hit.point);
                }
            }

            createMarker(pos) {
                const geo = new THREE.RingGeometry(0.2, 0.3, 8);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide });
                const marker = new THREE.Mesh(geo, mat);
                marker.rotation.x = -Math.PI / 2;
                marker.position.copy(pos);
                marker.position.y = 0.1;
                this.scene.add(marker);
                setTimeout(() => this.scene.remove(marker), 500);
            }

            createTeleportEffect(pos) {
                // Purple spiral
                const geometry = new THREE.CylinderGeometry(0.5, 0.5, 10, 8, 1, true);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xaa00ff, 
                    transparent: true, 
                    opacity: 0.5, 
                    side: THREE.DoubleSide 
                });
                const beam = new THREE.Mesh(geometry, material);
                beam.position.copy(pos);
                beam.position.y = 5;
                this.scene.add(beam);

                // Animate and remove
                const startTime = Date.now();
                const animateBeam = () => {
                    const elapsed = Date.now() - startTime;
                    if(elapsed > 1000) {
                        this.scene.remove(beam);
                        return;
                    }
                    beam.rotation.y += 0.2;
                    beam.scale.x -= 0.01;
                    beam.scale.z -= 0.01;
                    requestAnimationFrame(animateBeam);
                }
                animateBeam();
            }

            spawnParticles(pos, color, count) {
                const geo = new THREE.BufferGeometry();
                const positions = [];
                for(let i=0; i<count; i++) {
                    positions.push((Math.random()-0.5)*2, Math.random()*2, (Math.random()-0.5)*2);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                const mat = new THREE.PointsMaterial({ color: color, size: 0.2 });
                const points = new THREE.Points(geo, mat);
                points.position.copy(pos);
                this.scene.add(points);
                
                setTimeout(() => this.scene.remove(points), 500);
            }

            updateContext(text) {
                document.getElementById('context-menu').innerText = text;
            }

            // --- LOOP ---
            onResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                // Player Movement
                if(this.isMoving && this.player) {
                    const dir = new THREE.Vector3().subVectors(this.targetPos, this.player.position);
                    const dist = dir.length();
                    
                    if(dist < 0.2) {
                        this.isMoving = false;
                    } else {
                        dir.normalize();
                        this.player.position.add(dir.multiplyScalar(0.1)); // Speed
                        this.player.lookAt(this.targetPos.x, 3.5, this.targetPos.z);
                    }
                    
                    // Camera Follow
                    this.camera.position.x = this.player.position.x;
                    this.camera.position.z = this.player.position.z + 15;
                    this.camera.lookAt(this.player.position);
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Start Game
        new Game();
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>99 Nights - Survival</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; user-select: none; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        #game-container { position: relative; width: 100%; height: 100vh; }
        canvas { display: block; width: 100%; height: 100%; outline: none; }
        
        /* UI OVERLAY */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }

        .hud-top {
            position: absolute; top: 10px; width: 100%; text-align: center;
            color: white; text-shadow: 1px 1px 2px black; pointer-events: none;
        }

        .xp-bar-container {
            width: 200px; height: 10px; background: #333; margin: 5px auto;
            border: 1px solid #555; border-radius: 5px; overflow: hidden;
        }
        #xp-bar-fill { height: 100%; width: 0%; background: #00b06f; transition: width 0.2s; }

        /* MINIMAP */
        #minimap-container {
            position: absolute; top: 20px; right: 20px;
            width: 100px; height: 100px;
            background: rgba(0,0,0,0.5); border: 2px solid #777;
            border-radius: 50%; overflow: hidden; display: none;
        }
        #minimap-canvas { width: 100%; height: 100%; }

        /* INVENTORY */
        #inventory-bar {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(0,0,0,0.6); padding: 10px;
            border-radius: 10px; pointer-events: auto;
        }
        .inv-slot {
            width: 50px; height: 50px; background: rgba(255,255,255,0.1);
            border: 2px solid #555; border-radius: 5px; position: relative;
            display: flex; justify-content: center; align-items: center;
            color: white; font-size: 20px; user-select: none;
        }
        .item-icon { width: 40px; height: 40px; display: flex; justify-content: center; align-items: center; }
        .item-count { position: absolute; bottom: 2px; right: 2px; font-size: 10px; font-weight: bold; }

        /* BUTTONS */
        #jump-btn {
            position: absolute; bottom: 120px; right: 20px;
            width: 60px; height: 60px; background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.5); border-radius: 50%; color: white;
            font-weight: bold; font-size: 12px; display: flex; pointer-events: auto;
            justify-content: center; align-items: center; cursor: pointer;
            backdrop-filter: blur(2px);
        }
        #jump-btn:active { background: rgba(255,255,255,0.4); transform: scale(0.95); }

        #action-btn {
            position: absolute; bottom: 190px; right: 30px;
            width: 80px; height: 80px; background: rgba(0, 176, 111, 0.3);
            border: 3px solid #00b06f; border-radius: 50%; color: white;
            font-weight: bold; font-size: 30px; display: none; pointer-events: auto;
            justify-content: center; align-items: center; cursor: pointer;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        #action-btn:active { background: #00b06f; transform: scale(0.95); }

        /* CRAFT MENU */
        #craft-menu {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95); border: 2px solid #555; padding: 20px;
            color: white; display: none; pointer-events: auto; text-align: center;
            border-radius: 10px; width: 250px; z-index: 20;
        }
        .craft-btn {
            background: #333; color: white; border: 1px solid #555;
            padding: 10px; width: 100%; margin-bottom: 5px; cursor: pointer;
        }

        .exit-btn {
            position: absolute; top: 10px; left: 10px; pointer-events: auto;
            background: rgba(255,255,255,0.2); color: white;
            padding: 5px 10px; border-radius: 5px; text-decoration: none;
        }

        /* JOYSTICK */
        #joystick-zone {
            position: absolute; bottom: 100px; left: 30px;
            width: 100px; height: 100px; 
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%; pointer-events: auto; z-index: 15;
        }
        #joystick-knob {
            position: absolute; top: 50%; left: 50%;
            width: 40px; height: 40px; 
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none;
        }

        #touch-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; }

        #toast {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            background: rgba(0,0,0,0.7); color: white; padding: 10px 20px;
            border-radius: 20px; opacity: 0; transition: opacity 0.5s;
            pointer-events: none; font-size: 14px; text-align: center;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="touch-layer"></div>
        <div id="ui-layer">
            <a href="roblox.html" class="exit-btn">‚¨Ö Exit</a>
            
            <div class="hud-top">
                <div style="font-size: 18px; font-weight: bold;">Campfire Lv <span id="camp-lvl">1</span></div>
                <div class="xp-bar-container"><div id="xp-bar-fill"></div></div>
                <div><span id="time-display">Day 1</span></div>
            </div>

            <div id="minimap-container"><canvas id="minimap-canvas" width="100" height="100"></canvas></div>

            <div id="jump-btn" ontouchstart="jump(event)">JUMP</div>
            <div id="action-btn" ontouchstart="performAction(event)">üëã</div>
            <div id="toast">Message</div>

            <div id="inventory-bar">
                <div class="inv-slot" id="slot-0"><div class="item-icon" id="item-axe">ü™ì</div></div>
                <div class="inv-slot" id="slot-1"><div class="item-icon" id="item-sack">üéí<div class="item-count" id="sack-count">0/10</div></div></div>
                <div class="inv-slot" id="slot-2"></div>
                <div class="inv-slot" id="slot-3"></div>
                <div class="inv-slot" id="slot-4"></div>
            </div>

            <div id="craft-menu">
                <h3>Workbench</h3>
                <button class="craft-btn" onclick="craft('map')">üó∫Ô∏è Craft Map (5 Wood)</button>
                <button class="craft-btn" onclick="craft('bed')">üõèÔ∏è Craft Bed (10 Wood)</button>
                <button class="craft-btn" onclick="craft('upgrade_bench')">üõ†Ô∏è Upgrade Bench (20 Wood)</button>
                <button class="craft-btn" onclick="closeCraft()">Close</button>
            </div>
        </div>
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
    </div>

    <script>
        // --- GAME STATE ---
        const gameState = {
            wood: 0,
            maxWood: 10,
            xp: 0,
            xpToNextLevel: 100,
            campLevel: 1,
            // START AT 0.5 (NOON) to ensure it is bright!
            time: 0.5, 
            day: 1,
            nearbyObject: null,
            isSwinging: false,
            velocityY: 0,
            isGrounded: true,
            hasMap: false,
            fogDist: 25
        };

        const droppedLogs = [];
        const mobs = [];

        // --- 3D SETUP ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 5, gameState.fogDist);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.insertBefore(renderer.domElement, document.getElementById('touch-layer'));

        // --- CAMERA CONTROL ---
        let camRadius = 12; 
        let camTheta = Math.PI; 
        let camPhi = Math.PI / 3;
        let targetCamPhi = camPhi;
        let targetCamTheta = camTheta;

        // --- LIGHTING ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); // Increased base light
        scene.add(ambientLight);
        const sunLight = new THREE.DirectionalLight(0xffaa33, 1.2);
        sunLight.position.set(50, 50, 0);
        sunLight.castShadow = true;
        scene.add(sunLight);

        // GROUND
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({ color: 0x2f3628 }));
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- PLAYER ---
        const playerGroup = new THREE.Group();
        const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 0.5), new THREE.MeshStandardMaterial({color: 0xd35400}));
        body.position.y = 1;
        const head = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.6), new THREE.MeshStandardMaterial({color: 0xffe0bd}));
        head.position.y = 2.3;
        
        const sackGeo = new THREE.BoxGeometry(0.8, 0.8, 0.5);
        const sackMat = new THREE.MeshStandardMaterial({color: 0x8d6e63});
        const sack = new THREE.Mesh(sackGeo, sackMat);
        sack.position.set(0, 1.5, -0.4);
        playerGroup.add(sack);

        const axePivot = new THREE.Group();
        axePivot.position.set(0.6, 1.8, 0);
        const axeGroup = new THREE.Group();
        const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.2), new THREE.MeshStandardMaterial({color: 0x5d4037}));
        handle.position.y = 0.6;
        const blade = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.05), new THREE.MeshStandardMaterial({color: 0x95a5a6}));
        blade.position.set(0.15, 1.1, 0);
        axeGroup.add(handle); axeGroup.add(blade);
        axeGroup.rotation.x = Math.PI / 2;
        axeGroup.rotation.z = -0.2;
        axePivot.add(axeGroup);

        playerGroup.add(body); playerGroup.add(head); playerGroup.add(axePivot);
        playerGroup.castShadow = true;
        scene.add(playerGroup);

        // --- WORLD OBJECTS ---
        const fireGroup = new THREE.Group();
        const fireLight = new THREE.PointLight(0xff4500, 0, 15);
        fireLight.position.y = 1;
        fireGroup.add(fireLight);
        
        const log1 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), new THREE.MeshStandardMaterial({color: 0x3e2723}));
        log1.rotation.z = Math.PI/2; log1.position.y = 0.1;
        const log2 = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.5), new THREE.MeshStandardMaterial({color: 0x3e2723}));
        log2.rotation.x = Math.PI/2; log2.position.y = 0.1;
        fireGroup.add(log1); fireGroup.add(log2);
        
        for(let i=0; i<8; i++) {
            const p = new THREE.Mesh(new THREE.BoxGeometry(0.15,0.15,0.15), new THREE.MeshBasicMaterial({color: 0xffaa00}));
            p.position.set((Math.random()-0.5), Math.random()*1.5, (Math.random()-0.5));
            fireGroup.add(p);
        }
        scene.add(fireGroup);

        const bench = new THREE.Mesh(new THREE.BoxGeometry(2, 1, 1), new THREE.MeshStandardMaterial({color: 0x795548}));
        bench.position.set(6, 0.5, 6);
        scene.add(bench);

        // Trees
        const trees = [];
        const treeGeo = new THREE.ConeGeometry(1.5, 5, 6);
        const treeMat = new THREE.MeshStandardMaterial({color: 0x145a32});
        const trunkGeo = new THREE.CylinderGeometry(0.3, 0.4, 2);
        const trunkMat = new THREE.MeshStandardMaterial({color: 0x4e342e});

        function spawnTree(x, z) {
            const tGroup = new THREE.Group();
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1;
            const leaves = new THREE.Mesh(treeGeo, treeMat);
            leaves.position.y = 3.5;
            tGroup.add(trunk); tGroup.add(leaves);
            tGroup.position.set(x, 0, z);
            tGroup.castShadow = true;
            tGroup.userData = { hp: 3, type: 'tree' }; 
            scene.add(tGroup);
            trees.push(tGroup);
        }
        for(let i=0; i<60; i++) {
            let tx = (Math.random() - 0.5) * 150;
            let tz = (Math.random() - 0.5) * 150;
            if(Math.abs(tx) > 8 || Math.abs(tz) > 8) spawnTree(tx, tz);
        }

        // --- MOBS ---
        function spawnMob(type, x, z) {
            const mob = new THREE.Group();
            let color = type === 'wolf' ? 0x7f8c8d : 0xffffff;
            let size = type === 'wolf' ? 1 : 0.5;
            
            const body = new THREE.Mesh(new THREE.BoxGeometry(size, size/2, size*1.5), new THREE.MeshStandardMaterial({color: color}));
            body.position.y = size/2;
            const head = new THREE.Mesh(new THREE.BoxGeometry(size/1.5, size/1.5, size/1.5), new THREE.MeshStandardMaterial({color: color}));
            head.position.set(0, size, size/1.5);
            
            mob.add(body); mob.add(head);
            mob.position.set(x, 0, z);
            mob.userData = { type: type, speed: type === 'wolf' ? 0.08 : 0.03, moveTimer: 0 };
            scene.add(mob);
            mobs.push(mob);
        }
        for(let i=0; i<5; i++) spawnMob('wolf', (Math.random()-0.5)*80, (Math.random()-0.5)*80);
        for(let i=0; i<10; i++) spawnMob('bunny', (Math.random()-0.5)*80, (Math.random()-0.5)*80);

        // --- JOYSTICK ---
        const joyZone = document.getElementById('joystick-zone');
        const joyKnob = document.getElementById('joystick-knob');
        let moveX = 0, moveY = 0;

        function handleJoystick(x, y, isEnd) {
            if (isEnd) {
                joyKnob.style.transform = `translate(-50%, -50%)`;
                moveX = 0; moveY = 0; return;
            }
            const rect = joyZone.getBoundingClientRect();
            const cx = rect.left + rect.width / 2;
            const cy = rect.top + rect.height / 2;
            let dx = x - cx; let dy = y - cy;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDist = 50;
            if (dist > maxDist) { dx *= maxDist / dist; dy *= maxDist / dist; }
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            moveX = dx / maxDist; moveY = dy / maxDist;
        }
        joyZone.addEventListener('touchstart', e => handleJoystick(e.touches[0].clientX, e.touches[0].clientY));
        joyZone.addEventListener('touchmove', e => { e.preventDefault(); handleJoystick(e.touches[0].clientX, e.touches[0].clientY); });
        joyZone.addEventListener('touchend', () => handleJoystick(0,0,true));

        // --- TOUCH INPUT (Look, Zoom, Tap) ---
        const touchLayer = document.getElementById('touch-layer');
        let lastTouchX = 0, lastTouchY = 0, pinchStartDist = 0, startRadius = 12;

        touchLayer.addEventListener('touchstart', e => {
            if (e.touches.length === 1) {
                checkTap(e.touches[0].clientX, e.touches[0].clientY);
                lastTouchX = e.touches[0].clientX;
                lastTouchY = e.touches[0].clientY;
            }
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                pinchStartDist = Math.sqrt(dx*dx + dy*dy);
                startRadius = camRadius;
            }
        });

        touchLayer.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length === 1) {
                const x = e.touches[0].clientX; const y = e.touches[0].clientY;
                targetCamTheta -= (x - lastTouchX) * 0.005; 
                targetCamPhi -= (y - lastTouchY) * 0.005;
                targetCamPhi = Math.max(0.1, Math.min(Math.PI/2 - 0.1, targetCamPhi));
                lastTouchX = x; lastTouchY = y;
            }
            if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const ratio = pinchStartDist / Math.sqrt(dx*dx + dy*dy);
                camRadius = Math.max(5, Math.min(30, startRadius * ratio));
            }
        });

        // --- RAYCASTING ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        function checkTap(clientX, clientY) {
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(droppedLogs, true);
            if (intersects.length > 0) {
                const log = intersects[0].object;
                if (playerGroup.position.distanceTo(log.position) < 6) pickupLog(log);
                else showToast("Too far!");
            }
        }

        function pickupLog(logObj) {
            if(gameState.wood >= gameState.maxWood) {
                showToast("Sack is Full!");
                return;
            }
            scene.remove(logObj);
            const index = droppedLogs.indexOf(logObj);
            if (index > -1) droppedLogs.splice(index, 1);
            gameState.wood++;
            gameState.xp += 5;
            updateHUD();
            showToast("+1 Wood");
        }

        // --- ACTIONS ---
        function spawnLog(x, z) {
            const log = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 1), new THREE.MeshStandardMaterial({color: 0x8d6e63}));
            log.rotation.z = Math.PI / 2; log.rotation.y = Math.random() * Math.PI;
            log.position.set(x, 0.2, z); log.castShadow = true;
            scene.add(log); droppedLogs.push(log);
        }

        window.jump = (e) => { if(e) e.stopPropagation(); if (gameState.isGrounded) { gameState.velocityY = 0.3; gameState.isGrounded = false; } };
        window.performAction = (e) => {
            if(e) e.stopPropagation();
            if(!gameState.isSwinging) {
                gameState.isSwinging = true;
                let start = Date.now();
                let int = setInterval(() => {
                    let p = (Date.now()-start)/400;
                    if(p>=1) { axePivot.rotation.x = 0; gameState.isSwinging=false; clearInterval(int); }
                    else axePivot.rotation.x = Math.sin(p*Math.PI)*2;
                }, 16);
            }
            if (gameState.nearbyObject && gameState.nearbyObject.type === 'tree') {
                const t = gameState.nearbyObject.obj;
                setTimeout(() => {
                    t.userData.hp--; t.rotation.z = 0.2; setTimeout(() => t.rotation.z = 0, 100);
                    if(t.userData.hp <= 0) {
                        spawnLog(t.position.x, t.position.z); scene.remove(t);
                        trees.splice(trees.indexOf(t), 1); gameState.nearbyObject=null;
                        document.getElementById('action-btn').style.display='none';
                    }
                }, 200);
            } else if (gameState.nearbyObject && gameState.nearbyObject.type === 'fire') {
                 if (gameState.wood > 0) {
                    gameState.wood--; gameState.xp += 20; updateHUD(); showToast("Fueled Fire! +20 XP"); checkLevelUp();
                 } else showToast("No wood!");
            } else if (gameState.nearbyObject && gameState.nearbyObject.type === 'bench') {
                document.getElementById('craft-menu').style.display = 'block';
            }
        };

        function updateHUD() {
            document.getElementById('sack-count').innerText = `${gameState.wood}/${gameState.maxWood}`;
            const pct = (gameState.xp / gameState.xpToNextLevel) * 100;
            document.getElementById('xp-bar-fill').style.width = Math.min(100, pct) + '%';
            sack.scale.set(1 + (gameState.wood * 0.05), 1 + (gameState.wood * 0.05), 1 + (gameState.wood * 0.05));
        }

        function checkLevelUp() {
            if(gameState.xp >= gameState.xpToNextLevel) {
                gameState.campLevel++; gameState.xp = 0;
                gameState.xpToNextLevel = Math.floor(gameState.xpToNextLevel * 1.5);
                document.getElementById('camp-lvl').innerText = gameState.campLevel;
                gameState.fogDist += 15; scene.fog.far = gameState.fogDist;
                showToast(`Campfire Lv ${gameState.campLevel}! Fog receding.`);
                updateHUD();
                fireLight.distance += 5;
            }
        }
        
        window.craft = (i) => { 
            if(i === 'map') {
                if(gameState.wood >= 5) {
                    gameState.wood -= 5; gameState.hasMap = true;
                    document.getElementById('minimap-container').style.display = 'block';
                    showToast("Map Crafted!");
                } else showToast("Need 5 Wood");
            } else if(i === 'upgrade_bench') showToast("Bench Upgraded (Visual)");
            else if(i === 'bed') showToast("Bed Crafted");
            updateHUD(); document.getElementById('craft-menu').style.display='none'; 
        };
        window.closeCraft = () => document.getElementById('craft-menu').style.display='none';
        function showToast(msg) { const t = document.getElementById('toast'); t.innerText=msg; t.style.opacity=1; setTimeout(()=>t.style.opacity=0, 2000); }

        // --- MINIMAP ---
        const mapCanvas = document.getElementById('minimap-canvas');
        const mapCtx = mapCanvas.getContext('2d');
        function drawMinimap() {
            if(!gameState.hasMap) return;
            mapCtx.clearRect(0,0,100,100);
            mapCtx.fillStyle = "rgba(0,0,0,0.5)"; mapCtx.fillRect(0,0,100,100);
            
            // Draw Player
            mapCtx.fillStyle = "cyan"; mapCtx.beginPath(); mapCtx.arc(50, 50, 3, 0, Math.PI*2); mapCtx.fill();

            // Draw objects (Scale: 1 unit = 1.5 pixels)
            const scale = 1.0;
            const fx = 50 + (fireGroup.position.x - playerGroup.position.x) * scale;
            const fz = 50 + (fireGroup.position.z - playerGroup.position.z) * scale;
            if(fx>0 && fx<100 && fz>0 && fz<100) { mapCtx.fillStyle="orange"; mapCtx.fillRect(fx-2, fz-2, 4, 4); }
        }

        // --- LOOP ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            let dt = clock.getDelta();
            if(dt > 0.1) dt = 0.1; // Clamp lag spike

            // Environment
            gameState.time += dt / 180; // 3 min days
            if (gameState.time > 1) { gameState.time = 0; gameState.day++; }
            let hour = Math.floor(gameState.time * 24);
            let ampm = hour >= 12 ? 'PM' : 'AM';
            document.getElementById('time-display').innerText = `Day ${gameState.day} - ${hour%12||12}:00 ${ampm}`;

            const sunAngle = (gameState.time - 0.25) * Math.PI * 2; 
            sunLight.position.x = Math.cos(sunAngle) * 50; sunLight.position.y = Math.sin(sunAngle) * 50;
            // Prevent total blackness at night
            let intensity = Math.max(0, Math.sin(sunAngle));
            if(gameState.time > 0.75 || gameState.time < 0.25) intensity = 0;
            sunLight.intensity = intensity; 
            ambientLight.intensity = 0.3 + (intensity * 0.4); // Minimum 0.3 light
            scene.background.setHSL(0.6, 0.5, intensity * 0.5); 
            scene.fog.color.copy(scene.background);
            fireLight.intensity = (1 - intensity) * (2 + gameState.campLevel);

            // Mobs
            mobs.forEach(mob => {
                mob.userData.moveTimer += dt;
                if(mob.userData.type === 'bunny') {
                    if(mob.userData.moveTimer > 2) { mob.rotation.y = Math.random() * Math.PI * 2; mob.userData.moveTimer = 0; }
                    mob.position.z += Math.cos(mob.rotation.y) * 0.03; mob.position.x += Math.sin(mob.rotation.y) * 0.03;
                } else if(mob.userData.type === 'wolf') {
                    const dist = playerGroup.position.distanceTo(mob.position);
                    if(dist < 15 && dist > 1) {
                        mob.lookAt(playerGroup.position);
                        mob.position.z += Math.cos(mob.rotation.y) * 0.08; mob.position.x += Math.sin(mob.rotation.y) * 0.08;
                    } else if (mob.userData.moveTimer > 3) { mob.rotation.y = Math.random() * Math.PI * 2; mob.userData.moveTimer = 0; }
                }
            });

            // Physics
            gameState.velocityY -= 0.015; playerGroup.position.y += gameState.velocityY;
            if (playerGroup.position.y <= 0) { playerGroup.position.y = 0; gameState.velocityY = 0; gameState.isGrounded = true; }

            // Movement
            camTheta += (targetCamTheta - camTheta) * 0.1; camPhi += (targetCamPhi - camPhi) * 0.1;
            const fX = Math.sin(camTheta); const fZ = Math.cos(camTheta);
            const rX = Math.sin(camTheta + Math.PI/2); const rZ = Math.cos(camTheta + Math.PI/2);
            if (moveX !== 0 || moveY !== 0) {
                const wx = (rX * moveX) + (fX * moveY); const wz = (rZ * moveX) + (fZ * moveY);
                playerGroup.position.x += wx * 0.15; playerGroup.position.z += wz * 0.15;
                playerGroup.rotation.y = Math.atan2(wx, wz);
            }
            camera.position.x = playerGroup.position.x + camRadius * Math.sin(camTheta) * Math.sin(camPhi);
            camera.position.z = playerGroup.position.z + camRadius * Math.cos(camTheta) * Math.sin(camPhi);
            camera.position.y = playerGroup.position.y + camRadius * Math.cos(camPhi);
            camera.lookAt(playerGroup.position.x, playerGroup.position.y + 1, playerGroup.position.z);

            // Proximity UI
            const pPos = playerGroup.position;
            const btn = document.getElementById('action-btn');
            gameState.nearbyObject = null; btn.style.display = 'none';
            if (pPos.distanceTo(fireGroup.position) < 3.5) { gameState.nearbyObject = {type:'fire'}; btn.innerText='üî•'; btn.style.display='flex'; }
            else if (pPos.distanceTo(bench.position) < 3) { gameState.nearbyObject = {type:'bench'}; btn.innerText='üõ†Ô∏è'; btn.style.display='flex'; }
            else {
                for(let t of trees) {
                    if (pPos.distanceTo(t.position) < 2.5) { gameState.nearbyObject = {type:'tree', obj:t}; btn.innerText='ü™ì'; btn.style.display='flex'; break; }
                }
            }

            drawMinimap();
            renderer.render(scene, camera);
        }
        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rainbow Friends</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="roblox-joystick.js"></script>
    <script src="roblox-cam.js"></script>
    <script src="Rainbowfriends-level.js"></script> <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; user-select: none; }
        #game-container { position: relative; width: 100%; height: 100vh; }
        
        /* LAYERS */
        #touch-layer { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 10; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 20; }

        /* HUD */
        .hud { position: absolute; top: 20px; width: 100%; text-align: center; color: white; font-size: 24px; font-weight: bold; text-shadow: 0 0 10px #000; }
        .exit-btn { position: absolute; top: 10px; left: 10px; pointer-events: auto; background: rgba(255,255,255,0.2); color: white; padding: 8px 12px; border-radius: 8px; text-decoration: none; font-weight: bold; }

        /* BOX BUTTON */
        #box-btn {
            position: absolute; bottom: 100px; right: 30px;
            width: 80px; height: 80px;
            background: #d35400; border: 3px solid #e67e22;
            border-radius: 15px; color: white; font-size: 40px;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; cursor: pointer; box-shadow: 0 5px 0 #a04000;
        }
        #box-btn:active { transform: translateY(5px); box-shadow: none; }

        /* JOYSTICK */
        #joystick-zone { position: absolute; bottom: 80px; left: 40px; width: 100px; height: 100px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 255, 255, 0.3); border-radius: 50%; pointer-events: auto; z-index: 30; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 40px; height: 40px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; }

        /* CUTSCENE UI */
        #cutscene-overlay {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            width: 80%; background: rgba(0,0,0,0.8); color: white;
            padding: 20px; border-radius: 10px; text-align: center;
            font-size: 18px; border: 2px solid #c0392b;
            display: block; z-index: 50; /* Visible by default */
        }

        /* GAME OVER */
        #game-over {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 60;
            flex-direction: column; justify-content: center; align-items: center;
            color: white; pointer-events: auto;
        }
        .fail-text { font-size: 40px; font-weight: bold; color: #3498db; margin-bottom: 20px; }
        .retry-btn { padding: 15px 40px; font-size: 20px; background: white; border: none; border-radius: 30px; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <div id="game-container">
        <div id="touch-layer"></div>
        
        <div id="ui-layer">
            <a href="roblox.html" class="exit-btn">Exit</a>
            <div class="hud">Boxes: <span id="score">0</span>/5</div>
            <div id="box-btn" ontouchstart="toggleBox()">ðŸ“¦</div>
        </div>

        <div id="joystick-zone"><div id="joystick-knob"></div></div>

        <div id="cutscene-overlay">
            <div id="cutscene-text">Loading...</div>
        </div>

        <div id="game-over">
            <div class="fail-text">CAUGHT!</div>
            <button class="retry-btn" onclick="location.reload()">Try Again</button>
        </div>
    </div>

    <script>
        // --- 1. SETUP ---
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);
        scene.fog = new THREE.Fog(0x111111, 10, 60);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        container.insertBefore(renderer.domElement, document.getElementById('touch-layer'));

        // Init Camera Controller
        const rCam = new RobloxCamera(camera, document.getElementById('touch-layer'));

        // Lights
        const spot = new THREE.SpotLight(0xffffff, 1.2);
        spot.position.set(50, 100, 50); spot.castShadow = true; scene.add(spot);
        scene.add(new THREE.AmbientLight(0x404040, 0.8));

        // --- 2. ASSETS ---
        // Ensure Level is loaded
        if (typeof Level !== 'undefined') {
            Level.initMap(scene);
            var boxes = Level.spawnCollectibles(scene);
        } else {
            console.error("Rainbowfriends-level.js not loaded!");
            // Fallback floor if file missing
            const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            floor.rotation.x = -Math.PI / 2; scene.add(floor);
            var boxes = [];
        }

        // Player
        const player = (typeof createCharacterModel !== 'undefined') ? createCharacterModel() : new THREE.Mesh(new THREE.BoxGeometry(2,4,2), new THREE.MeshBasicMaterial({color:'green'}));
        player.position.set(15, 0, 15);
        player.userData = { isHiding: false, speed: 0.3 };
        scene.add(player);

        // Blue Monster
        const blue = (typeof createBlueMonster !== 'undefined') ? createBlueMonster() : new THREE.Mesh(new THREE.BoxGeometry(3,6,3), new THREE.MeshBasicMaterial({color:'blue'}));
        blue.position.set(80, 0, 80);
        scene.add(blue);

        // Red (Cutscene)
        const red = (typeof createRedCharacter !== 'undefined') ? createRedCharacter() : new THREE.Mesh(new THREE.BoxGeometry(2,4,2), new THREE.MeshBasicMaterial({color:'red'}));
        red.position.set(20, 0, 50); 
        red.lookAt(20, 0, 60);
        scene.add(red);

        // --- 3. CUTSCENE LOGIC ---
        let isCutscene = true;
        const cutsceneUI = document.getElementById('cutscene-overlay');
        const cutsceneText = document.getElementById('cutscene-text');

        // Set Camera to Cutscene Position IMMEDIATELY
        camera.position.set(20, 6, 60); 
        camera.lookAt(20, 3, 50); // Look at Red

        // Sequence
        setTimeout(() => cutsceneText.innerText = "RED: My blocks have gone missing...", 500);
        setTimeout(() => cutsceneText.innerText = "RED: Beware of Blue. He isn't friendly.", 2500);
        setTimeout(() => {
            // End Cutscene
            isCutscene = false;
            cutsceneUI.style.display = 'none';
            scene.remove(red);
            
            // CRITICAL: Snap camera to player
            rCam.tRadius = 30;
            rCam.tPhi = Math.PI / 4;
            rCam.update(player.position); 
        }, 5000);

        // --- 4. GAMEPLAY ACTIONS ---
        window.toggleBox = function() {
            if(isCutscene) return;
            player.userData.isHiding = !player.userData.isHiding;
            
            player.children.forEach(child => {
                if (child.name === 'hidingBox') child.visible = player.userData.isHiding;
                else child.visible = !player.userData.isHiding;
            });
            player.userData.speed = player.userData.isHiding ? 0.15 : 0.3;
        };

        // --- 5. MAIN LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            if (isCutscene) {
                // Static render during cutscene
                renderer.render(scene, camera);
                return;
            }

            // Movement
            if (window.joystick && window.joystick.active) {
                const moveX = window.joystick.x; const moveY = window.joystick.y;
                const angle = rCam.theta;
                
                const fX = Math.sin(angle); const fZ = Math.cos(angle);
                const rX = Math.sin(angle+Math.PI/2); const rZ = Math.cos(angle+Math.PI/2);
                
                const dx = (rX * moveX) + (fX * moveY);
                const dz = (rZ * moveX) + (fZ * moveY);
                
                player.position.x += dx * player.userData.speed;
                player.position.z += dz * player.userData.speed;
                player.rotation.y = Math.atan2(dx, dz);
            }

            // Camera Update
            rCam.update(player.position);

            // Blue AI
            const dist = player.position.distanceTo(blue.position);
            const detectionRange = player.userData.isHiding ? 6 : 40; 

            if(dist < detectionRange) {
                blue.lookAt(player.position);
                blue.position.z += Math.cos(blue.rotation.y) * 0.18;
                blue.position.x += Math.sin(blue.rotation.y) * 0.18;

                if (dist < 3) {
                    isCutscene = true; // Pause game
                    document.getElementById('game-over').style.display = 'flex';
                    document.getElementById('ui-layer').style.display = 'none';
                    document.getElementById('joystick-zone').style.display = 'none';
                }
            } else {
                blue.rotation.y += 0.02; // Idle spin
            }

            // Boxes
            for (let i = boxes.length - 1; i >= 0; i--) {
                boxes[i].rotation.y += 0.05;
                if (player.position.distanceTo(boxes[i].position) < 4) {
                    scene.remove(boxes[i]); boxes.splice(i, 1);
                    document.getElementById('score').innerText = (5 - boxes.length);
                    if(boxes.length === 0) { alert("YOU SURVIVED!"); location.href="roblox.html"; }
                }
            }

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Rainbow Friends 3D</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="roblox-joystick.js"></script>
    <script src="roblox-cam.js"></script> <style>
        body { overflow: hidden; background: #000; }
        #game-container { position: relative; width: 100%; height: 100vh; }
        #touch-layer { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 5; }
        .hud { position: absolute; top: 20px; width: 100%; text-align: center; color: white; font-size: 24px; font-weight: bold; pointer-events: none; z-index: 10; }
        .exit-link { position:absolute; top:10px; left:10px; z-index:20; color:white; background:rgba(255,255,255,0.1); padding:5px 10px; text-decoration:none; border-radius:5px; }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="touch-layer"></div>
        <a href="roblox.html" class="exit-link">Exit</a>
        <div class="hud">Cubes: <span id="score">0</span>/5</div>
    </div>

    <script>
        const container = document.getElementById('game-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x2d3436);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.insertBefore(renderer.domElement, document.getElementById('touch-layer'));

        // *** INIT CAMERA ***
        const rCam = new RobloxCamera(camera, document.getElementById('touch-layer'));

        const light = new THREE.PointLight(0xffffff, 1, 100);
        light.position.set(0, 20, 0); scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        const floor = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshStandardMaterial({ color: 0x636e72 }));
        floor.rotation.x = -Math.PI / 2; scene.add(floor);

        const player = { x: 0, z: 0, speed: 0.3 };
        const playerMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 1), new THREE.MeshStandardMaterial({ color: 0x00ff00 }));
        playerMesh.position.y = 1; scene.add(playerMesh);

        const blue = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 5, 12), new THREE.MeshStandardMaterial({ color: 0x0984e3 }));
        blue.position.set(20, 2.5, -20); scene.add(blue);

        let boxes = [];
        for(let i=0; i<5; i++) {
            const b = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.5, 1.5), new THREE.MeshStandardMaterial({color: 0xff9f43}));
            b.position.set((Math.random()-0.5)*60, 0.75, (Math.random()-0.5)*60);
            scene.add(b); boxes.push(b);
        }

        let collected = 0;

        function animate() {
            requestAnimationFrame(animate);

            // Movement (Camera Relative)
            if (window.joystick && window.joystick.active) {
                const moveX = window.joystick.getX(); const moveY = window.joystick.getY();
                const angle = rCam.theta;
                const fX = Math.sin(angle); const fZ = Math.cos(angle);
                const rX = Math.sin(angle+Math.PI/2); const rZ = Math.cos(angle+Math.PI/2);
                
                const dx = (rX * moveX) + (fX * moveY);
                const dz = (rZ * moveX) + (fZ * moveY);
                
                player.x += dx * player.speed;
                player.z += dz * player.speed;
                playerMesh.position.set(player.x, 1, player.z);
                playerMesh.rotation.y = Math.atan2(dx, dz);
            }

            // Update Camera
            rCam.update(playerMesh.position);

            // Monster Logic
            const dist = Math.sqrt((player.x - blue.position.x)**2 + (player.z - blue.position.z)**2);
            if(dist > 1.5) {
                blue.position.x += (player.x - blue.position.x) * 0.015;
                blue.position.z += (player.z - blue.position.z) * 0.015;
            } else { alert("CAUGHT!"); location.reload(); }

            // Box Logic
            for(let i=boxes.length-1; i>=0; i--) {
                const bDist = Math.sqrt((player.x - boxes[i].position.x)**2 + (player.z - boxes[i].position.z)**2);
                if(bDist < 2) {
                    scene.remove(boxes[i]); boxes.splice(i, 1); collected++;
                    document.getElementById('score').innerText = collected;
                    if(collected === 5) { alert("YOU WON!"); location.href="roblox.html"; }
                }
            }
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
